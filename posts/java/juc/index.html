<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JUC并发编程 | Cx`s Blog</title><meta name="author" content="Cx"><meta name="copyright" content="Cx"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Juc并发编程通俗易懂教程">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC并发编程">
<meta property="og:url" content="https://cxhahalala.github.io/posts/java/juc/index.html">
<meta property="og:site_name" content="Cx&#96;s Blog">
<meta property="og:description" content="Juc并发编程通俗易懂教程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://w.wallhaven.cc/full/je/wallhaven-je8q9w.jpg">
<meta property="article:published_time" content="2025-07-10T12:56:25.000Z">
<meta property="article:modified_time" content="2025-07-10T13:00:37.649Z">
<meta property="article:author" content="Cx">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://w.wallhaven.cc/full/je/wallhaven-je8q9w.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JUC并发编程",
  "url": "https://cxhahalala.github.io/posts/java/juc/",
  "image": "https://w.wallhaven.cc/full/je/wallhaven-je8q9w.jpg",
  "datePublished": "2025-07-10T12:56:25.000Z",
  "dateModified": "2025-07-10T13:00:37.649Z",
  "author": [
    {
      "@type": "Person",
      "name": "Cx",
      "url": "https://cxhahalala.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://cxhahalala.github.io/posts/java/juc/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JUC并发编程',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/Background/%E5%A4%B4%E5%83%8F1.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/photo/"><i class="fa-fw fas fa-camera"></i><span> 图片</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://w.wallhaven.cc/full/je/wallhaven-je8q9w.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Cx`s Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">JUC并发编程</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/photo/"><i class="fa-fw fas fa-camera"></i><span> 图片</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">JUC并发编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-10T12:56:25.000Z" title="发表于 2025-07-10 20:56:25">2025-07-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-10T13:00:37.649Z" title="更新于 2025-07-10 21:00:37">2025-07-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>Juc并发编程通俗易懂教程</p>
<span id="more"></span>


<h1 id="JUC并发编程"><a href="#JUC并发编程" class="headerlink" title="JUC并发编程"></a>JUC并发编程</h1><h2 id="1-什么是JUC"><a href="#1-什么是JUC" class="headerlink" title="1. 什么是JUC"></a>1. 什么是JUC</h2><p> JUC就是java.util.concurrent下面的类包，专门用于多线程的开发。<br> <img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250618183524057.png"></p>
<h2 id="2-线程和进程"><a href="#2-线程和进程" class="headerlink" title="2. 线程和进程"></a>2. 线程和进程</h2><blockquote>
<p>进程是操作系统中的应用程序、是资源分配的基本单位，线程是用来执行具体的任务和功能，是CPU调度和分派的最小单位</p>
<p>一个进程往往可以包含多个线程，至少包含一个</p>
</blockquote>
<h3 id="1）进程"><a href="#1）进程" class="headerlink" title="1）进程"></a>1）进程</h3><p><strong>一个程序，QQ.EXE Music.EXE；数据+代码+pcb</strong></p>
<p>一个进程可以包含多个线程，至少包含一个线程！</p>
<p>Java默认有几个线程？<strong>2个线程！</strong> main线程、GC线程</p>
<h3 id="2）线程"><a href="#2）线程" class="headerlink" title="2）线程"></a>2）线程</h3><p><strong>开了一个进程Typora，写字，等待几分钟会进行自动保存(线程负责的)</strong></p>
<p>对于Java而言：Thread、Runable、Callable进行开启线程的。</p>
<p><strong>提问？JAVA真的可以开启线程吗？ 开不了的！</strong></p>
<p>Java是没有权限去开启线程、操作硬件的，这是一个native的一个本地方法，它调用的底层的C++代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * This method is not invoked for the main method thread or &quot;system&quot;</span></span><br><span class="line"><span class="comment">        * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">        * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * A zero status value corresponds to state &quot;NEW&quot;.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">        * so that it can be added to the group&#x27;s list of threads</span></span><br><span class="line"><span class="comment">        * and the group&#x27;s unstarted count can be decremented. */</span></span><br><span class="line">       group.add(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">       <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           start0();</span><br><span class="line">           started = <span class="literal">true</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                   group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">               <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                 it will be passed up the call stack */</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//这是一个C++底层，Java是没有权限操作底层硬件的</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3）并发"><a href="#3）并发" class="headerlink" title="3）并发"></a>3）并发</h3><p>多线程操作同一个资源。</p>
<p><strong>并发（Concurrency）：</strong></p>
<ul>
<li>多个线程通过时间片轮转共享CPU资源</li>
<li>单核CPU：快速切换线程，营造”同时执行”的效果</li>
<li>多核CPU：线程数超过核心数时，仍需要时间片轮转</li>
</ul>
<p><strong>并发编程的本质：最大化利用CPU资源，避免CPU空闲等待！</strong></p>
<h3 id="4）并行"><a href="#4）并行" class="headerlink" title="4）并行"></a>4）并行</h3><p><strong>并行：</strong> 多个人一起行走</p>
<ul>
<li>CPU多核，多个线程可以同时执行。 我们可以使用线程池！</li>
</ul>
<p><strong>获取cpu的核数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取cpu的逻辑核心(线程)数量</span></span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5）线程的状态"><a href="#5）线程的状态" class="headerlink" title="5）线程的状态"></a>5）线程的状态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//运行</span></span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//运行</span></span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//阻塞</span></span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//等待</span></span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//超时等待</span></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//终止</span></span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6）wait-sleep"><a href="#6）wait-sleep" class="headerlink" title="6）wait&#x2F;sleep"></a>6）wait&#x2F;sleep</h3><p><strong>1、来自不同的类</strong></p>
<p>wait &#x3D;&gt; Object</p>
<p>sleep &#x3D;&gt; Thread</p>
<p>一般情况企业中使用休眠是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.TimeUnit;</span></span><br><span class="line">TimeUnit.DAYS.sleep(<span class="number">1</span>); <span class="comment">//休眠1天</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>); <span class="comment">//休眠1s</span></span><br></pre></td></tr></table></figure>

<p><strong>2、关于锁的释放</strong></p>
<p>wait wait要先得到锁才能执行,会释放锁；</p>
<p>sleep睡觉了，不会释放锁；</p>
<p><strong>3、使用的范围是不同的</strong></p>
<p>wait 必须在同步代码块中；(在多线程环境下，同一时间只有一个线程可以执行特定的代码段)</p>
<p>sleep 可以在任何地方睡；</p>
<p><strong>4、是否需要捕获异常</strong><br>两者都需要捕获异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.juc.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//获取逻辑核心（线程）</span></span><br><span class="line"></span><br><span class="line">    System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Test1</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test1</span>();</span><br><span class="line">    test.wait();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-Lock"><a href="#3-Lock" class="headerlink" title="3.Lock"></a>3.Lock</h2><h3 id="1）传统的-synchronized"><a href="#1）传统的-synchronized" class="headerlink" title="1）传统的 synchronized"></a>1）传统的 synchronized</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.juc.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicket</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">        <span class="comment">// lamda 表达式开启新的线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 资源类 OOP 属性、方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//卖票的方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出了第&quot;</span> + (number--) + <span class="string">&quot;张票剩余&quot;</span> + number + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2）Lock"><a href="#2）Lock" class="headerlink" title="2）Lock"></a>2）Lock</h3><p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250618194345757.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250618194144425.png"></p>
<p><strong>公平锁：</strong> 十分公平，必须先来后到~；</p>
<p><strong>非公平锁：</strong> 十分不公平，可以插队；**(默认为非公平锁)**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.juc.demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaleTicket1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Ticket1</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket1</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.获取锁</span></span><br><span class="line"><span class="comment">// 2.加锁</span></span><br><span class="line"><span class="comment">// 3.解锁</span></span><br><span class="line"><span class="comment">// 资源类 OOP 属性、方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket1</span>     &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//卖票的方式</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            lock.lock(); <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                 System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出了第&quot;</span> + (number--) + <span class="string">&quot;张票剩余&quot;</span> + number + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-Synchronized-与Lock-的区别"><a href="#3-Synchronized-与Lock-的区别" class="headerlink" title="3. Synchronized 与Lock 的区别"></a>3. Synchronized 与Lock 的区别</h3><p>1、Synchronized 内置的Java关键字，Lock是一个Java类</p>
<p>2、Synchronized 无法判断获取锁的状态，Lock可以判断</p>
<p>3、Synchronized 会自动释放锁，lock必须要手动加锁和手动释放锁！<strong>可能会遇到死锁</strong></p>
<p>4、Synchronized 线程1(获得锁-&gt;阻塞)、线程2(等待)；lock就不一定会一直等待下去，<strong>lock会有一个trylock去尝试获取锁</strong>，不会造成长久的等待。</p>
<p>5、Synchronized 是可重入锁，不可以中断的，非公平的；Lock，可重入的，可以判断锁，可以自己设置公平锁和非公平锁；</p>
<p>6、Synchronized 适合锁少量的代码同步问题，Lock适合锁大量的同步代码；</p>
<h2 id="4-生产者和消费者的关系"><a href="#4-生产者和消费者的关系" class="headerlink" title="4. 生产者和消费者的关系"></a>4. 生产者和消费者的关系</h2><h3 id="1）Synchronzied-版本"><a href="#1）Synchronzied-版本" class="headerlink" title="1）Synchronzied 版本"></a>1）Synchronzied 版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.juc.pc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                b.increment();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&quot;</span> + b.num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                b.decrement();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&quot;</span> + b.num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num--;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2）存在问题（虚假唤醒）"><a href="#2）存在问题（虚假唤醒）" class="headerlink" title="2）存在问题（虚假唤醒）"></a>2）存在问题（虚假唤醒）</h3><p><strong>问题，如果有四个线程</strong>，会出现虚假唤醒<br><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250620193917634.png"></p>
<p>解决方式 ，<strong>if 改为while即可，防止虚假唤醒</strong></p>
<blockquote>
<p>结论：就是用if判断的话，唤醒后线程会从wait之后的代码开始运行，但是不会重新判断if条件，直接继续运行if代码块之后的代码，而如果使用while的话，也会从wait之后的代码运行，但是唤醒后会重新判断循环条件，如果不成立再执行while代码块之后的代码块，成立的话继续wait。</p>
<p>这也就是为什么用while而不用if的原因了，因为线程被唤醒后，执行开始的地方是wait之后</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.juc.pc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                b.increment();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&quot;</span> + b.num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                b.decrement();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&quot;</span> + b.num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                b.decrement();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&quot;</span> + b.num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                b.increment();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&quot;</span> + b.num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num--;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解释:<br>初始num &#x3D; 0<br>P1进入<br>increment()<br>，检查num &#x3D;&#x3D; 0，不等待，执行num++（num变为1）<br>P2进入<br>increment()<br>，检查num !&#x3D; 0，调用wait()并释放锁<br>消费者线程C进入<br>decrement()<br>，消费num变为0，调用notifyAll()<br>P2被唤醒，但使用if时它会直接继续执行num++，导致num变为1<br>但是，如果使用while，P2会再次检查num !&#x3D; 0，发现num &#x3D;&#x3D; 0，所以会继续等待</p>
<p>为什么synchronized不足以保证线程安全？<br>synchronized保证的是互斥性：<br>确保同一时间只有一个线程可以进入同步方法<br>但是，当线程调用wait()时，它会释放锁并进入等待状态<br>问题出在wait()之后：<br>当线程A在wait()时释放了锁<br>其他线程（比如线程B）可以进入同步方法<br>当线程B调用notifyAll()时，所有等待的线程（包括线程A）都会被唤醒<br>线程A被唤醒后需要重新获取锁才能继续执行</p>
<h3 id="3）Lock版"><a href="#3）Lock版" class="headerlink" title="3）Lock版"></a>3）Lock版</h3><p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250620194328099.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250620195305445.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250620194427109.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.juc.pc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data2</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data2</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&quot;</span> + data.num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&quot;</span> + data.num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&quot;</span> + data.num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-&quot;</span> + data.num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断等待，业务，通知</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data2</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num--;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4）Condition的优势"><a href="#4）Condition的优势" class="headerlink" title="4）Condition的优势"></a>4）Condition的优势</h3><p>精准的通知和唤醒的线程！</p>
<p><strong>如果我们要指定通知的下一个进行顺序怎么办呢？ 我们可以使用Condition来指定通知进程~</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A-&gt;B</span></span><br><span class="line"><span class="comment">// B-&gt;C</span></span><br><span class="line"><span class="comment">// C-&gt;A</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">package</span> com.example.juc.pc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data3</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data3</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.printA();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.printB();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.printC();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断等待，业务，通知</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data3</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); </span><br><span class="line">    <span class="comment">// 创建多个condition</span></span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    condition1.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 唤醒B</span></span><br><span class="line">            condition2.signal();</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    condition2.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num = <span class="number">3</span>;</span><br><span class="line">            <span class="comment">// 唤醒C</span></span><br><span class="line">            condition3.signal();</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num != <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    condition3.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 唤醒A</span></span><br><span class="line">            condition1.signal();</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A==&gt; AAAA</span></span><br><span class="line"><span class="comment">B==&gt; BBBB</span></span><br><span class="line"><span class="comment">C==&gt; CCCC</span></span><br><span class="line"><span class="comment">A==&gt; AAAA</span></span><br><span class="line"><span class="comment">B==&gt; BBBB</span></span><br><span class="line"><span class="comment">C==&gt; CCCC</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="5-8锁现象"><a href="#5-8锁现象" class="headerlink" title="5. 8锁现象"></a>5. 8锁现象</h2><p>如何判断锁的是谁！锁到底锁的是谁？</p>
<p>锁会锁住：对象、Class</p>
<p>深刻理解我们的锁</p>
<p><strong>问题1</strong></p>
<p>两个同步方法，先执行发短信还是打电话</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">dome01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; phone.sendMs(); &#125;).start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; phone.call(); &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendMs</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为 </p>
<p>发短信</p>
<p>打电话</p>
<p><strong>为什么？ 如果你认为是顺序在前？ 这个答案是错误的！</strong></p>
<p><strong>问题2：</strong></p>
<p><strong>我们再来看：我们让发短信 延迟4s</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">dome01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendMs();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; phone.call(); &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendMs</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在结果是什么呢？</p>
<p>结果：<strong>还是先发短信，然后再打电话！</strong></p>
<p><strong>why？</strong></p>
<blockquote>
<p>原因：并不是顺序执行，而是synchronized 锁住的对象是方法的调用！对于两个方法用的是同一个锁，谁先拿到谁先执行，另外一个等待</p>
</blockquote>
<p><strong>问题三</strong></p>
<p>加一个普通方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">dome01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendMs();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; phone.hello(); &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendMs</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<p>hello</p>
<p>发短信</p>
<blockquote>
<p>原因：hello是一个普通方法，不受synchronized锁的影响，不用等待锁的释放</p>
</blockquote>
<p><strong>问题四</strong></p>
<p><strong>如果我们使用的是两个对象，一个调用发短信，一个调用打电话，那么整个顺序是怎么样的呢？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">dome01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone1.sendMs();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123; phone2.call(); &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sendMs</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p>打电话</p>
<p>发短信</p>
<blockquote>
<p>原因：两个对象两把锁，不会出现等待的情况，发短信睡了4s,所以先执行打电话</p>
</blockquote>
<p><strong>问题五、六</strong></p>
<p><strong>如果我们把synchronized的方法加上static变成静态方法！那么顺序又是怎么样的呢？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.juc.lockQuestions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 场景：两个对象实例，但调用的是它们的静态同步方法。</span></span><br><span class="line"><span class="comment"> * 预期打印顺序：phone1, phone2。</span></span><br><span class="line"><span class="comment"> * 解释：当使用 `synchronized` 锁定静态方法时，锁对象是类的 `Class` 对象。由于每个类只有一个 `Class` 对象，</span></span><br><span class="line"><span class="comment"> * 因此所有静态同步方法都共享同一个锁。这意味着即使存在多个对象实例，对静态同步方法的访问也是互斥的，</span></span><br><span class="line"><span class="comment"> * 从而保证了线程安全和预期的执行顺序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="comment">// 两个对象的Class类模板只有一个，static, 锁的是类的class</span></span><br><span class="line">        <span class="type">Phone3</span> <span class="variable">phone1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone3</span>();</span><br><span class="line">        <span class="type">Phone3</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone3</span>();   </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone1.phone1();</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone2.phone2();</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone3</span> &#123;</span><br><span class="line">    <span class="comment">// 对于synchronized实例方法，锁对象是当前实例(this)</span></span><br><span class="line">    <span class="comment">// 对于synchronized静态方法，锁对象是类的Class对象</span></span><br><span class="line">    <span class="comment">// 由于静态方法在类加载时初始化，所有静态同步方法共享同一个Class对象锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">phone1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 休眠5秒</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;phone1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">phone2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;phone2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（1）我们先来使用一个对象调用两个方法！</p>
<p>答案是：<strong>先打印phone1,后打印phone2</strong></p>
<p>（2）如果我们使用两个对象调用两个方法！</p>
<p>答案是：<strong>还是打印phone1,后打印phone2</strong></p>
<p>原因是什么呢？ <strong>为什么加了static就始终前面一个对象先执行呢！为什么后面会等待呢？</strong></p>
<p>原因是：<strong>对于static静态方法来说，对于整个类Class来说只有一份，对于不同的对象使用的是同一份方法，相当于这个方法是属于这个类的，如果静态static方法使用synchronized锁定，那么这个synchronized锁会锁住整个对象！不管多少个对象，对于静态的锁都只有一把锁，谁先拿到这个锁就先执行，其他的进程都需要等待！</strong></p>
<hr>
<p><strong>问题七</strong></p>
<p><strong>如果我们使用一个静态同步方法、一个同步方法、一个对象调用顺序是什么？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.juc.lockQuestions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步代码块和静态同步方法</span></span><br><span class="line"><span class="comment"> * 先打印phone2再打印phone1</span></span><br><span class="line"><span class="comment"> * 因为同步代码快和静态同步方法使用的不是同一把锁</span></span><br><span class="line"><span class="comment"> * 静态代码块锁的是Class</span></span><br><span class="line"><span class="comment"> * 而同步代码块锁的是具体的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="comment">// 两个对象的Class类模板只有一个，static, 锁的是类的class</span></span><br><span class="line">        <span class="type">Phone4</span> <span class="variable">phone1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone4</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone1.phone1();</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone1.phone2();</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone4</span> &#123;</span><br><span class="line">    <span class="comment">// 静态同步方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">phone1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 休眠5秒</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;phone1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步代码块</span></span><br><span class="line">     <span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">phone2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;phone2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先打印phone2 ，再打印phone1</p>
<blockquote>
<p>原因：因为一个锁的是Class类的模板，一个锁的是对象的调用者。所以不存在等待，直接运行。</p>
</blockquote>
<p><strong>小解</strong></p>
<p><strong>new</strong> 出来的 this 是具体的一个对象</p>
<p><strong>static Class</strong> 是唯一的一个模板</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>synchronized 是 Java 中用于实现线程同步的关键字，它通过<strong>监视器锁（Monitor Lock）</strong>来确保在同一时间只有一个线程可以执行被保护的代码，从而避免多线程环境下的数据竞争和不一致性。</p>
<p>synchronized 可以用于以下三种情况：</p>
<ol>
<li><p>同步实例方法（Synchronized Instance Method） ：</p>
<ul>
<li>当您将 synchronized 关键字应用于一个非静态方法时，它锁定的对象是 当前实例对象（ this ） 。这意味着，如果一个类的两个不同实例，它们各自的同步方法可以同时被不同的线程调用，因为它们锁的是不同的对象。但同一个实例的同步方法，在同一时间只能被一个线程访问。</li>
<li>示例： public synchronized void myMethod() { … }</li>
</ul>
</li>
<li><p>同步静态方法（Synchronized Static Method） ：</p>
<ul>
<li>当您将 synchronized 关键字应用于一个静态方法时，它锁定的对象是 当前类的 Class 对象 。由于一个类只有一个 Class 对象，因此所有对该类的静态同步方法的访问都将是互斥的，无论有多少个实例。</li>
<li>示例： public static synchronized void myStaticMethod() { … }</li>
</ul>
</li>
<li><p>同步代码块（Synchronized Block） ：</p>
<ul>
<li>这是最灵活的使用方式。您需要明确指定一个 对象作为锁 。只有获取到这个对象的监视器锁的线程才能进入同步代码块。</li>
<li>如果多个线程尝试进入同一个对象的同步代码块，它们将竞争同一个锁。</li>
<li>示例： synchronized (lockObject) { … }<ul>
<li>lockObject 可以是任何 Java 对象。通常，我们会选择一个私有的、不可变的、专门用于锁的对象，以避免外部代码意外地获取到这个锁。</li>
<li>在您提供的代码中， synchronized (“xxx”) 就是一个同步代码块，它锁定的就是字符串常量池中唯一的那个 “xxx” 字符串对象。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>核心要点：</p>
<ul>
<li>锁的是对象，而不是代码或线程。 synchronized 保护的是共享资源，通过锁定一个对象来控制对这些资源的访问。</li>
<li>互斥性。 任何时候，只有一个线程能够持有某个对象的监视器锁，从而保证了被 synchronized 保护的代码块的原子性。</li>
<li>可见性。 当一个线程释放锁时，它对共享变量的修改会立即刷新到主内存，确保其他线程在获取锁后能看到最新的值。</li>
<li>可重入性。 一个线程如果已经持有了某个对象的锁，那么它可以再次进入该对象的任何其他 synchronized 代码块或方法，而不会被自己阻塞。<br>理解 synchronized 的关键在于识别它到底锁定了哪个对象，因为所有竞争同一个对象的锁的线程都会被同步。</li>
</ul>
<h2 id="6-集合不安全"><a href="#6-集合不安全" class="headerlink" title="6. 集合不安全"></a>6. 集合不安全</h2><h3 id="1）List-不安全"><a href="#1）List-不安全" class="headerlink" title="1）List 不安全"></a>1）List 不安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.util.ConcurrentModificationException 并发修改异常！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                arrayList.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(arrayList);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会导致 java.util.ConcurrentModificationException 并发修改异常！</p>
<p><strong>ArrayList 在并发情况下是不安全的</strong></p>
<p>解决方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解决方案</span></span><br><span class="line"><span class="comment">         * 1. List&lt;String&gt; list = new Vector&lt;&gt;();</span></span><br><span class="line"><span class="comment">         * 2. List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</span></span><br><span class="line"><span class="comment">         * 3. List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CopyOnWriteArrayList</strong>：写入时复制！ <strong>COW 计算机程序设计领域的一种优化策略</strong> </p>
<p>核心思想是，如果有多个调用者（Callers）同时要求相同的资源（如内存或者是磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者视图修改资源内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此做法主要的优点是如果调用者没有修改资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。</p>
<p>读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的CopyOnWriteArrayList。</p>
<p>多个线程调用的时候，list，读取的时候，固定的，写入（存在覆盖操作）；在写入的时候避免覆盖，造成数据错乱的问题；</p>
<blockquote>
<p><strong>CopyOnWriteArrayList</strong>比<strong>Vector</strong>厉害在哪里？<br>JDK17中两者使用的都是Synchronized关键字来实现的：效率特别低下。</p>
</blockquote>
<p><strong>Vector</strong>底层是使用<strong>synchronized</strong>关键字来实现的：效率特别低下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250624164706749.png"><br><strong>CopyOnWriteArrayList</strong> </p>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250624165704307.png"></p>
<p>但<br>Vector：</p>
<ul>
<li>在读写操作时都加锁</li>
<li>适合读写都频繁且对数据一致性要求高的场景</li>
<li>高并发下性能较差<br>CopyOnWriteArrayList：</li>
<li>采用写时复制（Copy-On-Write）策略</li>
<li>读操作完全无锁，性能极高</li>
<li>写操作加锁，但会创建底层数组的新副本</li>
<li>适合读多写少的场景<br>简单来说，CopyOnWriteArrayList 通过空间换时间的方式，在读多写少的场景下提供了更好的并发性能，而 Vector 的锁粒度更粗，适合写操作较多的场景。</li>
</ul>
<h3 id="2）set-不安全"><a href="#2）set-不安全" class="headerlink" title="2）set 不安全"></a>2）set 不安全</h3><p><strong>Set和List同理可得:</strong> 多线程情况下，普通的Set集合是线程不安全的；</p>
<p>解决方案还是两种：</p>
<ul>
<li>使用Collections工具类的<strong>synchronized</strong>包装的Set类</li>
<li>使用CopyOnWriteArraySet 写入复制的<strong>JUC</strong>解决方案</li>
</ul>
<p>CopyOnWriteArraySet底层维护的是CopyOnWriteArrayList<br>所有操作都委托给这个 CopyOnWriteArrayList 来完成<br><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250624172108620.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());</span></span><br><span class="line"><span class="comment">         * 2. Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//        Set&lt;String&gt; set = new HashSet&lt;&gt;();</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                set.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(set);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HashSet底层是什么？</strong></p>
<p>hashSet底层就是一个<strong>HashMap</strong>；</p>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250624170927459.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250624171155112.png"><br>HashSet的add方法实际就是<strong>put</strong>方法，所有的元素都是<strong>key</strong>，<strong>value</strong>是<strong>PRESENT</strong>，<strong>PRESENT</strong>是一个<strong>static</strong>的<strong>Object</strong>对象；</p>
<h3 id="3）Map不安全"><a href="#3）Map不安全" class="headerlink" title="3）Map不安全"></a>3）Map不安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map 是这样用的吗？  不是，工作中不使用这个</span></span><br><span class="line"><span class="comment">//默认等价什么？ new HashMap&lt;&gt;(16,0.75);</span></span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//加载因子、初始化容量</span></span><br></pre></td></tr></table></figure>

<p>默认<strong>加载因子是0.75</strong>,默认的<strong>初始容量是16</strong><br><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250624173442171.png"></p>
<p>同样的HashMap基础类也存在<strong>并发修改异常</strong>！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//map 是这样用的吗？  不是，工作中不使用这个</span></span><br><span class="line">        <span class="comment">//默认等价什么？ new HashMap&lt;&gt;(16,0.75);</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解决方案</span></span><br><span class="line"><span class="comment">         * 1. Map&lt;String, String&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());</span></span><br><span class="line"><span class="comment">         *  Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//加载因子、初始化容量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="7-Callable"><a href="#7-Callable" class="headerlink" title="7. Callable"></a>7. Callable</h2><p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250701151858225.png"><br><strong>1、可以有返回值；<br>2、可以抛出异常；<br>3、方法不同，run()&#x2F;call()</strong><br>Thread只能接受Runablle, FutureTask实现了Runable接口，FutureTask可以包装Callable<br><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250701152957595.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250701153710385.png"><br>Callable接受的泛型是返回值的类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.juc.callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(myThread);</span><br><span class="line">        <span class="comment">// new Thread(new Runnacable())</span></span><br><span class="line">        <span class="comment">// new Thread(new FutureTask&lt;&gt;(Callable))</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> futureTask.get(); <span class="comment">// 可能会导致阻塞，一般放在代码最后或者异步通信</span></span><br><span class="line">        System.out.println(s);  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Callable接口，Callable接受泛型是返回值类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Callable&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;测试成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实际上只会打印一次Callable, FutureTask在被启动后，会缓存Callable的返回值，所以即使有多个线程，也不会打印多次Callable。call方法只会执行一次。<br>如果需要打印多次Callable，可以创建多个FutureTask实例。</p>
<h2 id="8-常用的辅助类"><a href="#8-常用的辅助类" class="headerlink" title="8. 常用的辅助类"></a>8. 常用的辅助类</h2><h3 id="1）CountDownLatch"><a href="#1）CountDownLatch" class="headerlink" title="1）CountDownLatch"></a>1）CountDownLatch</h3><p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250701155924134.png"><br>简单理解为一个减法计时器，只有当计数器归零时，才会继续向下执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.juc.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;以上线程执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主要方法：</p>
<ul>
<li>countDown 减一操作；</li>
<li>await 等待计数器归零</li>
</ul>
<p>await 等待计数器归零，就唤醒，再继续向下运行</p>
<h3 id="2）CyclickBarrier"><a href="#2）CyclickBarrier" class="headerlink" title="2）CyclickBarrier"></a>2）CyclickBarrier</h3><p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250701162332223.png"></p>
<p>从概念上讲，CyclicBarrier可以理解为一种“加法计数器”或者“集合点”：它等待参与者数量达到预设值，而不是像CountDownLatch那样等待计数器减到零。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.juc.add;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyClickBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 公共屏障点为7，当7个线程都到达屏障点时，执行召唤神龙</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">7</span> , () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;召唤神龙&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;集齐7颗龙珠&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;上面线程已经全部执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3）Semaphore"><a href="#3）Semaphore" class="headerlink" title="3）Semaphore"></a>3）Semaphore</h3><p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250701163230155.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.juc.add;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaPhoreDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 信号量，许可数为3  资源//限流使用</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取信号量</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取许可&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;释放许可&quot;</span>); </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                      <span class="comment">// 释放信号量</span></span><br><span class="line">                      semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>获取许可</span><br><span class="line"><span class="number">1</span>获取许可</span><br><span class="line"><span class="number">3</span>获取许可</span><br><span class="line"><span class="number">1</span>释放许可</span><br><span class="line"><span class="number">2</span>释放许可</span><br><span class="line"><span class="number">4</span>获取许可</span><br><span class="line"><span class="number">5</span>获取许可</span><br><span class="line"><span class="number">3</span>释放许可</span><br><span class="line"><span class="number">6</span>获取许可</span><br><span class="line"><span class="number">4</span>释放许可</span><br><span class="line"><span class="number">5</span>释放许可</span><br><span class="line"><span class="number">6</span>释放许可</span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>原理：</p>
<p><strong>semaphore.acquire()获得资源，如果资源已经使用完了，就等待资源释放后再进行使用！</strong></p>
<p><strong>semaphore.release()释放，会将当前的信号量释放+1，然后唤醒等待的线程！</strong></p>
<p>作用： 多个共享资源互斥的使用！ 并发限流，控制最大的线程数！</p>
<h2 id="9-读写锁"><a href="#9-读写锁" class="headerlink" title="9. 读写锁"></a>9. 读写锁</h2><p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250705095608336.png"></p>
<p>读写锁即允许多个线程读取，但是写入的时候，其他线程必须等待！<br>线程的启动顺序不等于执行顺序</p>
<p>&#x2F;**</p>
<ul>
<li>独占锁(写锁)：一次只能被一个线程占有</li>
<li>共享锁(读锁)：可以被多个线程占有</li>
<li>ReadWriteLock:</li>
<li>读-读：可以共存</li>
<li>读-写：不能共存</li>
<li>写-读：不能共存</li>
<li>写-写：不能共存<br> *&#x2F;</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyCache</span> <span class="variable">myCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCache</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                myCache.write(String.valueOf(finalI), String.valueOf(finalI));</span><br><span class="line"></span><br><span class="line">            &#125;,String.valueOf(finalI)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                myCache.read(String.valueOf(finalI));</span><br><span class="line"></span><br><span class="line">            &#125;,String.valueOf(finalI)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  方法未加锁，导致写的时候被插队</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程开始写入&quot;</span>);</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程写入ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程开始读取&quot;</span>);</span><br><span class="line">        map.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程写读取ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span>线程开始写入</span><br><span class="line"><span class="number">5</span>线程开始读取</span><br><span class="line"><span class="number">2</span>线程开始写入 #  线程<span class="number">6</span>尚未写入完成，线程<span class="number">2</span>插队写入</span><br><span class="line"><span class="number">4</span>线程开始读取</span><br><span class="line"><span class="number">3</span>线程开始读取</span><br><span class="line"><span class="number">3</span>线程开始写入</span><br><span class="line"><span class="number">3</span>线程写入ok</span><br><span class="line"><span class="number">2</span>线程开始读取</span><br><span class="line"><span class="number">1</span>线程开始读取</span><br><span class="line"><span class="number">1</span>线程写读取ok</span><br><span class="line"><span class="number">6</span>线程开始读取</span><br><span class="line"><span class="number">1</span>线程开始写入</span><br><span class="line"><span class="number">1</span>线程写入ok</span><br><span class="line"><span class="number">6</span>线程写读取ok</span><br><span class="line"><span class="number">2</span>线程写读取ok</span><br><span class="line"><span class="number">4</span>线程开始写入</span><br><span class="line"><span class="number">5</span>线程开始写入</span><br><span class="line"><span class="number">5</span>线程写入ok</span><br><span class="line"><span class="number">3</span>线程写读取ok</span><br><span class="line"><span class="number">4</span>线程写读取ok</span><br><span class="line"><span class="number">2</span>线程写入ok</span><br><span class="line"><span class="number">5</span>线程写读取ok</span><br><span class="line"><span class="number">6</span>线程写入ok</span><br><span class="line"><span class="number">4</span>线程写入ok</span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>所以如果我们不加锁的情况，多线程的读写会造成数据不可靠的问题。</p>
<p>我们也可以采用<strong>synchronized</strong>这种重量锁和轻量锁 <strong>lock</strong>去保证数据的可靠。</p>
<p>但是这次我们采用更细粒度的锁：<strong>ReadWriteLock</strong> 读写锁来保证</p>
<p>读写锁和Lock锁的区别:</p>
<ol>
<li><p><strong>锁的粒度</strong></p>
<ul>
<li>[Lock]：只有一种锁，完全互斥</li>
<li>[ReadWriteLock]：细分为读锁和写锁</li>
</ul>
</li>
<li><p><strong>并发性能</strong></p>
<ul>
<li>[Lock]：任何时候都只允许一个线程访问（无论是读还是写）</li>
<li>[ReadWriteLock]：<ul>
<li>读-读：可以并发执行</li>
<li>读-写：互斥</li>
<li>写-写：互斥</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>使用场景</strong></p>
<ul>
<li><a href="cci:2://file:///c:/JavaProjects/juc/src/main/java/com/example/juc/rw/ReadWriteLockDemo.java:6:0-30:1">Lock</a>：<ul>
<li>适用于读写操作都很少</li>
<li>或者读写操作时间很短的场景</li>
</ul>
</li>
<li><a href="cci:2://file:///c:/JavaProjects/juc/src/main/java/com/example/juc/rw/ReadWriteLockDemo.java:6:0-30:1">ReadWriteLock</a>：<ul>
<li>适用于读多写少的场景</li>
<li>可以显著提高并发性能</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyCache2</span> <span class="variable">myCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCache2</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                myCache.write(String.valueOf(finalI), String.valueOf(finalI));</span><br><span class="line"></span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                myCache.read(String.valueOf(finalI));</span><br><span class="line"></span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCache2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        lock.writeLock().lock(); <span class="comment">// 写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程开始写入&quot;</span>);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程写入ok&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.writeLock().unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        lock.readLock().lock(); <span class="comment">// 读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程开始读取&quot;</span>);</span><br><span class="line">            map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程写读取ok&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.readLock().unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>线程开始写入</span><br><span class="line"><span class="number">1</span>线程写入ok</span><br><span class="line"><span class="number">2</span>线程开始写入</span><br><span class="line"><span class="number">2</span>线程写入ok</span><br><span class="line"><span class="number">6</span>线程开始写入</span><br><span class="line"><span class="number">6</span>线程写入ok</span><br><span class="line"><span class="number">5</span>线程开始写入</span><br><span class="line"><span class="number">5</span>线程写入ok</span><br><span class="line"><span class="number">4</span>线程开始写入</span><br><span class="line"><span class="number">4</span>线程写入ok</span><br><span class="line"><span class="number">3</span>线程开始写入</span><br><span class="line"><span class="number">3</span>线程写入ok</span><br><span class="line"><span class="number">1</span>线程开始读取</span><br><span class="line"><span class="number">2</span>线程开始读取</span><br><span class="line"><span class="number">5</span>线程开始读取</span><br><span class="line"><span class="number">5</span>线程写读取ok</span><br><span class="line"><span class="number">4</span>线程开始读取</span><br><span class="line"><span class="number">1</span>线程写读取ok</span><br><span class="line"><span class="number">3</span>线程开始读取</span><br><span class="line"><span class="number">4</span>线程写读取ok</span><br><span class="line"><span class="number">6</span>线程开始读取</span><br><span class="line"><span class="number">2</span>线程写读取ok</span><br><span class="line"><span class="number">6</span>线程写读取ok</span><br><span class="line"><span class="number">3</span>线程写读取ok</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以看到写锁是独占的，读锁是共享的。</p>
<h2 id="10-阻塞队列"><a href="#10-阻塞队列" class="headerlink" title="10. 阻塞队列"></a>10. 阻塞队列</h2><p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250705110800326.png"><br>Deque即双端队列，两边都可以取出元素</p>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250705104440688.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250705104636073.png"></p>
<h3 id="1）BlockQueue概述"><a href="#1）BlockQueue概述" class="headerlink" title="1）BlockQueue概述"></a>1）BlockQueue概述</h3><p><code>BlockingQueue</code> 是 <code>Queue</code> 的子接口，而 <code>Queue</code> 是 <code>Collection</code> 的子接口，<code>Collection</code> 又继承自 <code>Iterable</code>。</p>
<p>什么情况下我们会使用阻塞队列</p>
<blockquote>
<p>多线程并发处理、线程池</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250705105326589.png"></p>
<p>BlockingQueue 有四组api</p>
<table>
<thead>
<tr>
<th align="center">方式</th>
<th align="center">抛出异常</th>
<th align="center">不会抛出异常，有返回值</th>
<th align="center">阻塞，等待</th>
<th align="center">超时等待</th>
</tr>
</thead>
<tbody><tr>
<td align="center">添加</td>
<td align="center">add</td>
<td align="center">offer</td>
<td align="center">put</td>
<td align="center">offer(timenum,timeUnit)</td>
</tr>
<tr>
<td align="center">移出</td>
<td align="center">remove</td>
<td align="center">poll</td>
<td align="center">take</td>
<td align="center">poll(timenum,timeUnit)</td>
</tr>
<tr>
<td align="center">获取队首元素</td>
<td align="center">element</td>
<td align="center">peek</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//需要初始化队列的大小</span></span><br><span class="line">        <span class="type">ArrayBlockingQueue</span> <span class="variable">blockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="string">&quot;c&quot;</span>));</span><br><span class="line">        <span class="comment">//抛出异常：java.lang.IllegalStateException: Queue full</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.add(&quot;d&quot;));</span></span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        <span class="comment">//如果多移除一个</span></span><br><span class="line">        <span class="comment">//这也会造成 java.util.NoSuchElementException 抛出异常</span></span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">    &#125;</span><br><span class="line">=======================================================================================</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不抛出异常，有返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ArrayBlockingQueue</span> <span class="variable">blockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;c&quot;</span>));</span><br><span class="line">        <span class="comment">//添加 一个不能添加的元素 使用offer只会返回false 不会抛出异常</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="string">&quot;d&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        <span class="comment">//弹出 如果没有元素 只会返回null 不会抛出异常</span></span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">    &#125;</span><br><span class="line">=======================================================================================</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待 一直阻塞</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ArrayBlockingQueue</span> <span class="variable">blockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一直阻塞 不会返回</span></span><br><span class="line">        blockingQueue.put(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        blockingQueue.put(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        blockingQueue.put(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果队列已经满了， 再进去一个元素  这种情况会一直等待这个队列 什么时候有了位置再进去，程序不会停止</span></span><br><span class="line"><span class="comment">//        blockingQueue.put(&quot;d&quot;);</span></span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        <span class="comment">//如果我们再来一个  这种情况也会等待，程序会一直运行 阻塞</span></span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">    &#125;</span><br><span class="line">=======================================================================================</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待 超时阻塞</span></span><br><span class="line"><span class="comment">     *  这种情况也会等待队列有位置 或者有产品 但是会超时结束</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ArrayBlockingQueue</span> <span class="variable">blockingQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        blockingQueue.offer(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        blockingQueue.offer(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        blockingQueue.offer(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;开始等待&quot;</span>);</span><br><span class="line">        blockingQueue.offer(<span class="string">&quot;d&quot;</span>,<span class="number">2</span>, TimeUnit.SECONDS);  <span class="comment">//超时时间2s 等待如果超过2s就结束等待</span></span><br><span class="line">        System.out.println(<span class="string">&quot;结束等待&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===========取值==================&quot;</span>);</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;开始等待&quot;</span>);</span><br><span class="line">        blockingQueue.poll(<span class="number">2</span>,TimeUnit.SECONDS); <span class="comment">//超过两秒 我们就不要等待了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;结束等待&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2）同步队列SynchronousQueue"><a href="#2）同步队列SynchronousQueue" class="headerlink" title="2）同步队列SynchronousQueue"></a>2）同步队列SynchronousQueue</h3><p>同步队列 没有容量，也可以视为<strong>容量为1的队列</strong>；</p>
<p>进去一个元素，必须等待取出来之后，才能再往里面放入一个元素；</p>
<p><strong>put</strong>方法 和 <strong>take</strong>方法；</p>
<p><strong>Synchronized</strong> 和 其他的<strong>BlockingQueue</strong> 不一样 它不存储元素；</p>
<p>put了一个元素，就必须从里面先take出来，否则不能再put进去值！</p>
<p>并且SynchronousQueue 的take是使用了<strong>lock锁保证线程安全</strong>的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronousQueue</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; synchronousQueue = <span class="keyword">new</span> <span class="title class_">java</span>.util.concurrent.SynchronousQueue&lt;&gt;();</span><br><span class="line">        <span class="comment">// 向queue中添加元素</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;put 01&quot;</span>);</span><br><span class="line">                synchronousQueue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;put 02&quot;</span>);</span><br><span class="line">                synchronousQueue.put(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;put 03&quot;</span>);</span><br><span class="line">                synchronousQueue.put(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">// 取出元素</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;take&quot;</span> + synchronousQueue.take());</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;take&quot;</span> + synchronousQueue.take());</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;take&quot;</span> + synchronousQueue.take());</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread-0put <span class="number">01</span></span><br><span class="line">Thread-1take1</span><br><span class="line">Thread-0put <span class="number">02</span></span><br><span class="line">Thread-1take2</span><br><span class="line">Thread-0put <span class="number">03</span></span><br><span class="line">Thread-1take3</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="11-线程池"><a href="#11-线程池" class="headerlink" title="11. 线程池"></a>11. 线程池</h2><p>CPU核心数决定同一时刻能真正并行执行的线程数量（如8核&#x3D;8线程），但通过时间片轮转，系统可以”同时”运行更多线程，实际能创建的线程数主要受内存限制。</p>
<p>线程池：三大方式、七大参数、四种拒绝策略</p>
<blockquote>
<p>池化技术</p>
</blockquote>
<p>程序的运行，本质：占用系统的资源！我们需要去优化资源的使用 &#x3D;&#x3D;&#x3D;&gt; 池化技术</p>
<p>线程池、JDBC的连接池、内存池、对象池 等等。。。。</p>
<p>资源的 <strong>创建、销毁</strong> 十分消耗资源</p>
<p><strong>池化技术</strong>：事先准备好一些资源，如果有人要用，就来我这里拿，用完之后还给我，以此来提高效率。</p>
<h3 id="1）线程池的好处："><a href="#1）线程池的好处：" class="headerlink" title="1）线程池的好处："></a>1）线程池的好处：</h3><p>1、降低资源的消耗；</p>
<p>2、提高响应的速度；</p>
<p>3、方便管理；</p>
<p><strong>线程复用、可以控制最大并发数、管理线程；</strong></p>
<h3 id="2）线程池：三大方法"><a href="#2）线程池：三大方法" class="headerlink" title="2）线程池：三大方法"></a>2）线程池：三大方法</h3><ul>
<li><strong>ExecutorService threadPool &#x3D; Executors.newSingleThreadExecutor();&#x2F;&#x2F;单个线程</strong></li>
<li><strong>ExecutorService threadPool2 &#x3D; Executors.newFixedThreadPool(5); &#x2F;&#x2F;创建一个固定的线程池的大小</strong></li>
<li><strong>ExecutorService threadPool3 &#x3D; Executors.newCachedThreadPool(); &#x2F;&#x2F;可伸缩的</strong><br>可伸缩线程池，当任务提交速度&gt;线程处理速度的时候，会创建新的线程，当任务提交速度&lt;线程处理速度的时候，会销毁多余的线程</li>
</ul>
<p>使用execute()或submit()方法提交任务<br>使用完线程池必须要关闭线程池 shutdown();</p>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250705150759498.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工具类 Executors 三大方法；</span></span><br><span class="line"><span class="keyword">package</span> com.example.juc.Excutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//单个线程</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool1</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="comment">// 固定大小为5个线程的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool2</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//可伸缩的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool3</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">                threadPool3.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;执行&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭线程池</span></span><br><span class="line">            threadPool1.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3）七大参数"><a href="#3）七大参数" class="headerlink" title="3）七大参数"></a>3）七大参数</h3><p>查看源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">          (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE, <span class="comment">//21亿</span></span><br><span class="line">                                    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看出创建线程池的三种方法底层都是创建的ThreadPoolExecutor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,  //核心线程池大小</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize, //最大的线程池大小</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,  //空闲线程存活时间</span></span><br><span class="line"><span class="params">                          TimeUnit unit, //超时单位</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue, //阻塞队列</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory, //线程工厂 创建线程的 一般不用动</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler //拒绝策略</span></span><br><span class="line"><span class="params">                         )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250705151908769.png"><br>一图看懂线程池七大参数<br>corePoolSize 即，核心线程数，一直存活的线程数量<br>workQueue，阻塞队列，核心线程都在被使用，那么新的任务将被放入阻塞队列中等待<br>maximumPoolSize，最大线程数，当阻塞队列也满了的时候，就会创建新的线程，直到达到最大线程数</p>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250705145125279.png"></p>
<p>阿里巴巴的Java操作手册中明确说明：对于Integer.MAX_VALUE初始值较大，所以一般情况我们要使用底层的<strong>ThreadPoolExecutor</strong>来创建线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.juc.Excutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//单个线程</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool1</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="comment">// 固定大小为5个线程的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool2</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//可伸缩的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool3</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用ThreadPoolExecutor自定义线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">5</span>,</span><br><span class="line">                <span class="number">3</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="comment">// new ThreadPoolExecutor.AbortPolicy() // 阻塞队列和线程池都满了，抛出异常</span></span><br><span class="line">                <span class="comment">// new ThreadPoolExecutor.CallerRunsPolicy() // 哪来的回哪里</span></span><br><span class="line">                <span class="comment">// new ThreadPoolExecutor.DiscardPolicy() // 阻塞队列和线程池都满了，丢弃任务，不抛出异常</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy() <span class="comment">// 阻塞队列和线程池都满了，尝试和最早的线程竞争，竞争成功则执行，竞争失败则丢弃</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 最大承载，Deque+max</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">                threadPool4.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;执行&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭线程池</span></span><br><span class="line">            threadPool4.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4）拒绝策略"><a href="#4）拒绝策略" class="headerlink" title="4）拒绝策略"></a>4）拒绝策略</h3><p><strong>1. new ThreadPoolExecutor.AbortPolicy()：</strong> &#x2F;&#x2F;该拒绝策略为：银行满了，还有人进来，不处理这个人的，并抛出异常</p>
<p>超出最大承载，就会抛出异常：队列容量大小+maxPoolSize</p>
<p><strong>2. new ThreadPoolExecutor.CallerRunsPolicy()：</strong> &#x2F;&#x2F;该拒绝策略为：哪来的去哪里</p>
<p><strong>3. new ThreadPoolExecutor.DiscardPolicy():</strong> &#x2F;&#x2F;该拒绝策略为：队列满了,丢掉异常，不会抛出异常。</p>
<p><strong>4. new ThreadPoolExecutor.DiscardOldestPolicy()：</strong> &#x2F;&#x2F;该拒绝策略为： 阻塞队列和线程池都满了，丢弃队列中最老的任务，尝试将新任务加入队列，若队列还是满的拒绝，不会丢出异常</p>
<h3 id="5）如何设置线程池的大小"><a href="#5）如何设置线程池的大小" class="headerlink" title="5）如何设置线程池的大小"></a>5）如何设置线程池的大小</h3><p><strong>1、CPU密集型：电脑的核数是几核就选择几；选择maximunPoolSize的大小</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取cpu 的核数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                max,</span><br><span class="line">                <span class="number">3</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>

<p><strong>2、I&#x2F;O密集型：</strong></p>
<p>在程序中有15个大型任务，io十分占用资源；I&#x2F;O密集型就是判断我们程序中十分耗I&#x2F;O的线程数量，大约是最大I&#x2F;O数的一倍到两倍之间。</p>
<h2 id="12-四大函数式接口"><a href="#12-四大函数式接口" class="headerlink" title="12. 四大函数式接口"></a>12. 四大函数式接口</h2><p>新时代的程序员：<strong>lambda表达式、链式编程、函数式接口、Stream流式计算</strong></p>
<blockquote>
<p>简化编程模型</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250705165743356.png"></p>
<h3 id="1）Function-函数型接口"><a href="#1）Function-函数型接口" class="headerlink" title="1）Function 函数型接口"></a>1）Function 函数型接口</h3><blockquote>
<p>函数式接口：只包含 一个且仅一个 抽象方法 (abstract method) 的接口。<br>抽象方法是只有方法签名，没有方法体的方法<br>抽象类里必须显式写 abstract，接口里可以省略。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250705170105185.png"><br>传入参数T,返回类型R</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.juc.function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">        <span class="comment">// Function&lt;Integer, Integer&gt; function =  new Function&lt;Integer, Integer&gt;() &#123;</span></span><br><span class="line">        <span class="comment">//     @Override</span></span><br><span class="line">        <span class="comment">//     public Integer apply(Integer integer) &#123;</span></span><br><span class="line">        <span class="comment">//         return integer * integer;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;;</span></span><br><span class="line">        <span class="comment">//可以使用lambda表达式实现函数式接口</span></span><br><span class="line">        Function&lt;Integer, Integer&gt; function = (x) -&gt; &#123;<span class="keyword">return</span> x * x;&#125;;</span><br><span class="line">        System.out.println(function.apply(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2）Predicate-断定型接口"><a href="#2）Predicate-断定型接口" class="headerlink" title="2）Predicate 断定型接口"></a>2）Predicate 断定型接口</h3><p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250705172734549.png"><br>有一个输入参数，返回值只能是boolean类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.juc.function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Predicate&lt;String&gt; predicate = (s) -&gt; &#123;<span class="keyword">return</span> s.length() &gt; <span class="number">5</span>;&#125;;</span><br><span class="line">        System.out.println(predicate.test(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3）Suppier-供给型接口"><a href="#3）Suppier-供给型接口" class="headerlink" title="3）Suppier 供给型接口"></a>3）Suppier 供给型接口</h3><p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250705173404065.png"><br>没有输入只有返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 供给型接口，只返回，不输入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Supplier&lt;String&gt; supplier = ()-&gt;&#123;<span class="keyword">return</span> <span class="string">&quot;1024&quot;</span>;&#125;;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4）Consummer-消费型接口"><a href="#4）Consummer-消费型接口" class="headerlink" title="4）Consummer 消费型接口"></a>4）Consummer 消费型接口</h3><p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250705173136801.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费型接口 没有返回值！只有输入！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Consumer&lt;String&gt; consumer = (str)-&gt;&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;;</span><br><span class="line">        consumer.accept(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="13-Stream-流式计算"><a href="#13-Stream-流式计算" class="headerlink" title="13. Stream 流式计算"></a>13. Stream 流式计算</h2><p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250705174150099.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.juc.stream;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * * 题目要求： 用一行代码实现</span></span><br><span class="line"><span class="comment"> * 1. Id 必须是偶数</span></span><br><span class="line"><span class="comment"> * 2.年龄必须大于23</span></span><br><span class="line"><span class="comment"> * 3. 用户名转为大写</span></span><br><span class="line"><span class="comment"> * 4. 用户名倒序</span></span><br><span class="line"><span class="comment"> * 5. 只能输出一个用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">6</span>, <span class="string">&quot;d&quot;</span>, <span class="number">24</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">4</span>, <span class="string">&quot;e&quot;</span>, <span class="number">25</span>);</span><br><span class="line">        <span class="comment">// 集合就是存储数据的</span></span><br><span class="line">        List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算交给Stream</span></span><br><span class="line">        <span class="comment">// 链式编程</span></span><br><span class="line">        list.stream().filter((u) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> u.getId() % <span class="number">2</span> == <span class="number">0</span>; <span class="comment">// 判断Id是否为偶数</span></span><br><span class="line">        &#125;).filter((u) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> u.getAge() &gt; <span class="number">23</span>; <span class="comment">// 判断年龄是否大于23</span></span><br><span class="line">        &#125;).map((u) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> u.getName().toUpperCase(); <span class="comment">// 用户名转为大写</span></span><br><span class="line">        &#125;).sorted((s1, s2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> -s1.compareTo(s2); <span class="comment">// 用户名倒序</span></span><br><span class="line">        &#125;).limit(<span class="number">1</span>).forEach(System.out::println); <span class="comment">// 只能输出一个用户</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>流式计算的结果也可以进行收集</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; result = list.stream()</span><br><span class="line">    .filter(u -&gt; u.getId() % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    .filter(u -&gt; u.getAge() &gt; <span class="number">23</span>)</span><br><span class="line">    .map(u -&gt; u.getName().toUpperCase())</span><br><span class="line">    .sorted(Comparator.reverseOrder())</span><br><span class="line">    .limit(<span class="number">1</span>)</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用结果</span></span><br><span class="line">result.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h2 id="14-ForkJoin"><a href="#14-ForkJoin" class="headerlink" title="14. ForkJoin"></a>14. ForkJoin</h2><p>ForkJoin 在JDK1.7，并行执行任务！提高效率~。在大数据量速率会更快！</p>
<p>大数据中：<strong>MapReduce 核心思想-&gt;把大任务拆分为小任务！</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250705185412596.png"></p>
<h3 id="1）ForkJoin-特点：-工作窃取！"><a href="#1）ForkJoin-特点：-工作窃取！" class="headerlink" title="1）ForkJoin 特点： 工作窃取！"></a>1）ForkJoin 特点： 工作窃取！</h3><p>实现原理是：<strong>双端队列</strong>！从上面和下面都可以去拿到任务进行执行！</p>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250705185531344.png"></p>
<p>线程B执行完后，会从线程A的队列中拿任务执行，这就是工作窃取！</p>
<h3 id="2）如何使用ForkJoin"><a href="#2）如何使用ForkJoin" class="headerlink" title="2）如何使用ForkJoin?"></a>2）如何使用ForkJoin?</h3><ul>
<li><p>1、通过<strong>ForkJoinPool</strong>来执行</p>
</li>
<li><p>2、计算任务 <strong>execute(ForkJoinTask&lt;?&gt; task)</strong></p>
</li>
<li><p>3、计算类要去继承ForkJoinTask；</p>
<p><strong>ForkJoin 的计算类</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinDemo</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> star;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> end;</span><br><span class="line">    <span class="comment">/** 临界值 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">1000000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ForkJoinDemo</span><span class="params">(<span class="type">long</span> star, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.star = star;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((end - star) &lt; temp) &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Long</span> <span class="variable">i</span> <span class="operator">=</span> star; i &lt; end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 使用ForkJoin 分而治之 计算</span></span><br><span class="line">            <span class="comment">//1 . 计算平均值</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">middle</span> <span class="operator">=</span> (star + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">ForkJoinDemo</span> <span class="variable">forkJoinDemo1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(star, middle);</span><br><span class="line">            <span class="comment">// 拆分任务，把线程压入线程队列</span></span><br><span class="line">            forkJoinDemo1.fork();</span><br><span class="line">            <span class="type">ForkJoinDemo</span> <span class="variable">forkJoinDemo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(middle, end);</span><br><span class="line">            forkJoinDemo2.fork();</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">taskSum</span> <span class="operator">=</span> forkJoinDemo1.join() + forkJoinDemo2.join();</span><br><span class="line">            <span class="keyword">return</span> taskSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.LongStream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">SUM</span> <span class="operator">=</span> <span class="number">20_0000_0000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        test1();</span><br><span class="line">        test2();</span><br><span class="line">        test3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用普通方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">star</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; SUM ; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        System.out.println(<span class="string">&quot;时间：&quot;</span> + (end - star));</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用ForkJoin 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">star</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(<span class="number">0L</span>, SUM);</span><br><span class="line">        ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">along</span> <span class="operator">=</span> submit.get();</span><br><span class="line"></span><br><span class="line">        System.out.println(along);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;时间：&quot;</span> + (end - star));</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 Stream 流计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">star</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> LongStream.range(<span class="number">0L</span>, <span class="number">20_0000_0000L</span>).parallel().reduce(<span class="number">0</span>, Long::sum);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;时间：&quot;</span> + (end - star));</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>.parallel().reduce(0, Long::sum)使用一个并行流去计算整个计算，提高效率。</strong></p>
<h2 id="异步编程与回调：从理念到-CompletableFuture-实战"><a href="#异步编程与回调：从理念到-CompletableFuture-实战" class="headerlink" title="异步编程与回调：从理念到 CompletableFuture 实战"></a>异步编程与回调：从理念到 <code>CompletableFuture</code> 实战</h2><h3 id="1-核心理念：什么是异步？什么是回调？"><a href="#1-核心理念：什么是异步？什么是回调？" class="headerlink" title="1. 核心理念：什么是异步？什么是回调？"></a>1. 核心理念：什么是异步？什么是回调？</h3><p>在深入 <code>CompletableFuture</code> 之前，我们必须理解两个基本概念。</p>
<h4 id="什么是回调-Callback-？"><a href="#什么是回调-Callback-？" class="headerlink" title="什么是回调 (Callback)？"></a><strong>什么是回调 (Callback)？</strong></h4><p>回调是一种编程模式：你定义一个函数（A），然后将它作为参数传递给另一个函数（B）。函数B在执行到某个特定时机时，会“回过头来调用”你传给它的函数A。</p>
<p><strong>生活比喻：</strong> 你去餐厅点餐，服务员给了你一个<strong>震动取餐器</strong>。</p>
<ul>
<li><strong>任务发起</strong>：你点完餐，付了钱。</li>
<li><strong>回调注册</strong>：服务员把取餐器（回调的“凭证”）给你。</li>
<li><strong>主线程解放</strong>：你不用站在柜台干等，可以回到座位玩手机、聊天（主线程可以做其他事）。</li>
<li><strong>回调触发</strong>：厨房把餐做好了（异步任务完成），服务员按下了按钮，你的取餐器震动了（回调函数被执行）。</li>
<li><strong>结果处理</strong>：你去取餐。</li>
</ul>
<p>这里的“取餐器震动”这个动作，就是<strong>回调</strong>。</p>
<h4 id="什么是异步-Asynchronous-？"><a href="#什么是异步-Asynchronous-？" class="headerlink" title="什么是异步 (Asynchronous)？"></a><strong>什么是异步 (Asynchronous)？</strong></h4><p>异步的核心是 <strong>“立即返回，不阻塞”</strong>。</p>
<p>当你调用一个异步方法时，它会立即返回，让你的主线程可以继续执行后续代码，而那个耗时的任务则在后台（通常是另一个线程）悄悄进行。</p>
<p><strong>前端AJAX的例子非常贴切：</strong></p>
<ul>
<li><strong>同步（synchronous）</strong>：浏览器发送请求 → <strong>必须等服务器响应完毕</strong> → 才能继续执行后续JS代码／渲染UI。在这段等待过程中，页面会“卡住”。</li>
<li><strong>异步（asynchronous）</strong>：浏览器发送请求后<strong>不阻塞主线程</strong>；JS继续往下执行。当服务器返回数据时，会通过一个<strong>回调函数</strong>（如 <code>Promise.then</code>）来处理响应。这种非阻塞模型让页面依旧可交互，体验更流畅。</li>
</ul>
<p><strong>异步回调</strong>，就是将这两者结合：发起一个不会阻塞当前线程的任务，并预先指定一个回调函数，以便在任务完成后自动处理其结果或异常。<code>CompletableFuture</code> 正是 Java 中实现这一模式的利器。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250705194740585.png"></p>
<hr>
<h3 id="2-CompletableFuture-入门：创建异步任务"><a href="#2-CompletableFuture-入门：创建异步任务" class="headerlink" title="2. CompletableFuture 入门：创建异步任务"></a>2. <code>CompletableFuture</code> 入门：创建异步任务</h3><p><code>CompletableFuture</code> 提供了两种主要方式来创建异步任务。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
<th align="left">对应的函数式接口</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>runAsync</code></td>
<td align="left">执行一个没有返回值的异步任务。</td>
<td align="left"><code>Runnable</code></td>
</tr>
<tr>
<td align="left"><code>supplyAsync</code></td>
<td align="left">执行一个带有返回值的异步任务。</td>
<td align="left"><code>Supplier&lt;T&gt;</code></td>
</tr>
</tbody></table>
<p><strong>注意</strong>：若不指定线程池（<code>Executor</code>），默认使用 <code>ForkJoinPool.commonPool()</code>。对于I&#x2F;O密集型任务，强烈建议自定义线程池，以避免阻塞<code>commonPool</code>中宝贵的计算线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1) 没有返回值的异步任务 (runAsync)</span></span><br><span class="line">CompletableFuture&lt;Void&gt; futureRun = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这是一个没有返回值的异步任务...&quot;</span>);</span><br><span class="line">    <span class="comment">// 适合执行日志记录、消息发送等操作</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2) 带有返回值的异步任务 (supplyAsync)</span></span><br><span class="line">CompletableFuture&lt;String&gt; futureSupply = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 适合执行数据库查询、远程API调用等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, Async!&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3) 使用自定义线程池执行</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">myThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; futureWithPool = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 模拟调用远程服务</span></span><br><span class="line">    <span class="keyword">return</span> callRemoteService();</span><br><span class="line">&#125;, myThreadPool);</span><br></pre></td></tr></table></figure>

<h4 id="重要：get-是阻塞的！"><a href="#重要：get-是阻塞的！" class="headerlink" title="重要：get() 是阻塞的！"></a><strong>重要：<code>get()</code> 是阻塞的！</strong></h4><p><code>get()</code> 方法会<strong>阻塞当前线程</strong>，直到异步任务完成。它通常用于程序的最后，或者当你确实需要同步等待结果时。在异步流的中间过程滥用 <code>get()</code> 会使其失去异步的意义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程开始...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>); <span class="comment">// 模拟耗时任务</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;异步任务在线程: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 执行完毕&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;主线程不阻塞，继续执行其他代码...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 get() 会让主线程在这里停下，直到异步任务完成</span></span><br><span class="line">    future.get();</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程在 get() 后继续执行，程序结束。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-核心能力：构建异步回调流水线"><a href="#3-核心能力：构建异步回调流水线" class="headerlink" title="3. 核心能力：构建异步回调流水线"></a>3. 核心能力：构建异步回调流水线</h3><p><code>CompletableFuture</code> 的真正威力在于其<strong>链式调用</strong>能力，可以优雅地构建处理流水线。</p>
<h4 id="示例：一个完整的异步处理流程"><a href="#示例：一个完整的异步处理流程" class="headerlink" title="示例：一个完整的异步处理流程"></a>示例：一个完整的异步处理流程</h4><p>下面示例演示了这些典型场景：获取一个数字 -&gt; 记录日志 -&gt; 处理异常 -&gt; 转换结果 -&gt; 再发起另一个异步任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个自定义线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; finalResultFuture = CompletableFuture</span><br><span class="line">    <span class="comment">// ① 异步计算，返回 1024。可以解开注释模拟异常</span></span><br><span class="line">    .supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务1（supplyAsync）- 线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">2</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        <span class="comment">// int i = 1/0; // 模拟异常</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">    &#125;, executor)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ② 注册回调：无论成功/失败都会执行，但【不能】改变结果。常用于打日志。</span></span><br><span class="line">    .whenComplete((result, exception) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务2（whenComplete）- 线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">if</span> (exception == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;上一步执行成功，结果: &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;上一步执行失败，异常: &quot;</span> + exception.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ③ 注册异常回调：仅在出现异常时触发，用于提供“兜底”数据，让流水线继续。</span></span><br><span class="line">    .exceptionally(exception -&gt; &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;任务3（exceptionally）- 捕获到异常: &quot;</span> + exception.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">404</span>; <span class="comment">// 返回一个替代结果，future 会转为正常完成状态</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ④ 注册成功回调：对上一步的结果进行转换 (Integer -&gt; String)</span></span><br><span class="line">    .thenApply(result -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务4（thenApply）- 线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;最终结果: &quot;</span> + result;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⑤ 注册成功回调：继续执行另一个异步任务，并将两个任务“连接”起来</span></span><br><span class="line">    <span class="comment">// thenCompose 用于解决 CompletableFuture&lt;CompletableFuture&lt;T&gt;&gt; 嵌套问题</span></span><br><span class="line">    .thenCompose(str -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务5（thenCompose）- 线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; str + <span class="string">&quot; -&gt; 再加上用户信息&quot;</span>, executor);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在主线程最后，阻塞等待最终结果</span></span><br><span class="line">System.out.println(<span class="string">&quot;主线程已提交所有任务，等待最终结果...&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;最终拿到的结果是: &quot;</span> + finalResultFuture.join());</span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>执行顺序说明</strong></p>
<ol>
<li><code>supplyAsync</code> 是流水线的起点，它产生原始结果或异常。</li>
<li><code>whenComplete</code> <strong>总是</strong>会被执行，它像一个观察者，只能“看”结果&#x2F;异常，但不能修改。</li>
<li>如果 <code>supplyAsync</code> 抛出异常，<code>exceptionally</code> 会捕获它并返回一个备用值，从而让流水线从异常状态恢复为正常状态，后续的 <code>thenApply</code> 才能继续执行。若无异常，<code>exceptionally</code> 会被跳过。</li>
<li><code>thenApply</code> 对<strong>成功的结果</strong>进行转换。<code>thenAccept</code> 则只消费结果，不返回值。</li>
<li><code>thenCompose</code> 用于连接两个有依赖关系的异步任务。它会将 <code>CompletableFuture&lt;CompletableFuture&lt;T&gt;&gt;</code> 这种嵌套结构“压平”成 <code>CompletableFuture&lt;T&gt;</code>，使流水线保持清爽。</li>
</ol>
</blockquote>
<hr>
<h3 id="4-常用-API-小结与对比"><a href="#4-常用-API-小结与对比" class="headerlink" title="4. 常用 API 小结与对比"></a>4. 常用 API 小结与对比</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">何时触发</th>
<th align="left">是否可改变结果</th>
<th align="left">返回类型</th>
<th align="left">核心用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>whenComplete</code></td>
<td align="left">成功 &#x2F; 失败</td>
<td align="left"><strong>否</strong></td>
<td align="left">原类型 <code>CompletableFuture&lt;T&gt;</code></td>
<td align="left">日志、监控等<strong>副作用</strong>操作</td>
</tr>
<tr>
<td align="left"><code>exceptionally</code></td>
<td align="left"><strong>仅失败</strong></td>
<td align="left"><strong>是</strong>（提供兜底值）</td>
<td align="left"><code>CompletableFuture&lt;T&gt;</code></td>
<td align="left">异常恢复，提供默认值</td>
</tr>
<tr>
<td align="left"><code>handle</code></td>
<td align="left">成功 &#x2F; 失败</td>
<td align="left"><strong>是</strong></td>
<td align="left"><code>CompletableFuture&lt;U&gt;</code></td>
<td align="left">无论成功失败都要处理并<strong>转换结果</strong></td>
</tr>
<tr>
<td align="left"><code>thenApply</code></td>
<td align="left"><strong>仅成功</strong></td>
<td align="left"><strong>是</strong>（映射）</td>
<td align="left"><code>CompletableFuture&lt;U&gt;</code></td>
<td align="left">同步地转换结果</td>
</tr>
<tr>
<td align="left"><code>thenAccept</code></td>
<td align="left"><strong>仅成功</strong></td>
<td align="left"><strong>否</strong> (消费)</td>
<td align="left"><code>CompletableFuture&lt;Void&gt;</code></td>
<td align="left">同步地消费结果，无后续</td>
</tr>
<tr>
<td align="left"><code>thenCompose</code></td>
<td align="left"><strong>仅成功</strong></td>
<td align="left"><strong>是</strong>（扁平化）</td>
<td align="left"><code>CompletableFuture&lt;U&gt;</code></td>
<td align="left"><strong>连接</strong>两个<strong>异步</strong>任务</td>
</tr>
</tbody></table>
<h4 id="get-vs-join-的区别"><a href="#get-vs-join-的区别" class="headerlink" title="get() vs join() 的区别"></a><code>get()</code> vs <code>join()</code> 的区别</h4><p>两者都用于阻塞等待结果，但异常处理方式不同。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">抛出异常类型</th>
<th align="left">中断处理</th>
<th align="left">典型场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>get()</code></td>
<td align="left"><strong>受检异常</strong> (<code>InterruptedException</code>, <code>ExecutionException</code>)</td>
<td align="left">调用者必须 <code>try-catch</code></td>
<td align="left">在需要精细化处理特定异常（如中断）的业务层使用</td>
</tr>
<tr>
<td align="left"><code>join()</code></td>
<td align="left"><strong>非受检异常</strong> (<code>CompletionException</code>)</td>
<td align="left">内部处理中断，不向外抛 <code>InterruptedException</code></td>
<td align="left">在 Lambda 表达式、链式调用末端或 <code>main</code> 方法中，用于简化代码</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>小技巧</strong>：在业务代码的底层（如DAO&#x2F;Service）可以使用 <code>get()</code> 进行细致的异常处理。而在上层（如Controller）或测试代码中，可以直接使用 <code>join()</code> 来简化代码，让全局异常处理器来捕获 <code>CompletionException</code>。</p>
</blockquote>
<hr>
<h3 id="5-组合多个异步任务"><a href="#5-组合多个异步任务" class="headerlink" title="5. 组合多个异步任务"></a>5. 组合多个异步任务</h3><table>
<thead>
<tr>
<th align="left">组合方法</th>
<th align="left">作用</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>allOf(f1,f2,...)</code></td>
<td align="left">等待 <strong>所有</strong> 任务都完成（返回 <code>Void</code>）</td>
<td align="left"><code>CompletableFuture.allOf(f1,f2).join();</code></td>
</tr>
<tr>
<td align="left"><code>anyOf(f1,f2,...)</code></td>
<td align="left">等待 <strong>任意一个</strong> 任务完成（返回 <code>Object</code>）</td>
<td align="left"><code>anyOf(f1,f2).thenAccept(System.out::println);</code></td>
</tr>
<tr>
<td align="left"><code>thenCombine(f1,f2,fn)</code></td>
<td align="left">当<strong>两个</strong>任务都完成后，合并它们的结果</td>
<td align="left"><code>f1.thenCombine(f2, (r1, r2) -&gt; r1 + r2);</code></td>
</tr>
<tr>
<td align="left"><code>applyToEither(f1,f2,fn)</code></td>
<td align="left">当<strong>两个</strong>任务中<strong>任意一个</strong>完成后，使用它的结果</td>
<td align="left"><code>f1.applyToEither(f2, result -&gt; &quot;Fastest: &quot; + result);</code></td>
</tr>
</tbody></table>
<h3 id="6-超时控制-JDK-9"><a href="#6-超时控制-JDK-9" class="headerlink" title="6. 超时控制 (JDK 9+)"></a>6. 超时控制 (JDK 9+)</h3><p>处理外部依赖时，超时控制至关重要。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; cf = CompletableFuture.supplyAsync(() -&gt; slowApiCall());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式一：超时后返回默认值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result1</span> <span class="operator">=</span> cf.completeOnTimeout(<span class="string">&quot;默认值&quot;</span>, <span class="number">3</span>, TimeUnit.SECONDS).join();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：超时后抛出异常</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result2</span> <span class="operator">=</span> cf.orTimeout(<span class="number">3</span>, TimeUnit.SECONDS).join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CompletionException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> TimeoutException) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;任务超时了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>completeOnTimeout</code>：超时后让 Future <strong>正常完成</strong>并返回一个默认值。</li>
<li><code>orTimeout</code>：超时后让 Future <strong>异常完成</strong>，抛出 <code>TimeoutException</code>。</li>
</ul>
<hr>
<h3 id="异步回调对比同步任务的优势"><a href="#异步回调对比同步任务的优势" class="headerlink" title="异步回调对比同步任务的优势"></a>异步回调对比同步任务的优势</h3><p>核心区别在于：<strong>主线程在“等待”期间，是在“忙碌地做别的事”还是在“被动地阻塞”？</strong></p>
<h4 id="1-传统同步模式：被动的“阻塞”"><a href="#1-传统同步模式：被动的“阻塞”" class="headerlink" title="1. 传统同步模式：被动的“阻塞”"></a>1. 传统同步模式：被动的“阻塞”</h4><p>在同步模式下，当主线程调用一个耗时方法（比如数据库查询）时，它会<strong>完全卡住</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程：开始查询数据库...&quot;</span>);</span><br><span class="line">    <span class="comment">// 这个方法会执行5秒钟</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> queryDatabase(); <span class="comment">// &lt;--- 主线程卡在这里，动弹不得，CPU时间片被浪费</span></span><br><span class="line">    System.out.println(<span class="string">&quot;主线程：终于拿到结果：&quot;</span> + result);</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程：结束。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>主线程的状态</strong>：<strong>阻塞（Blocked）</strong>。它的执行指针停在了 <code>queryDatabase()</code> 这一行，无法前进。它什么也做不了，只能干等。</li>
<li><strong>资源浪费</strong>：这个线程虽然没在做计算，但它仍然占用了内存（线程栈）和操作系统资源。如果这是一个Web服务器的请求处理线程，那么这个线程在这5秒内无法处理任何其他新的请求。</li>
</ul>
<p><strong>生活比喻</strong>：你去银行办业务，柜员告诉你需要等5分钟。于是你<strong>只能站在柜台前，盯着他，什么都不能做</strong>，直到他办完。你的时间被完全占用了。</p>
<hr>
<h4 id="2-异步回调模式：主动的“等待”或“继续工作”"><a href="#2-异步回调模式：主动的“等待”或“继续工作”" class="headerlink" title="2. 异步回调模式：主动的“等待”或“继续工作”"></a>2. 异步回调模式：主动的“等待”或“继续工作”</h4><p>在异步模式下，主线程发起一个异步调用后，它<strong>立即就返回了</strong>，可以继续执行后面的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程：已提交异步数据库查询...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CompletableFuture.supplyAsync(() -&gt; queryDatabase()) <span class="comment">// 任务被甩给后台线程池</span></span><br><span class="line">        .thenAccept(result -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;回调线程：拿到结果：&quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;主线程：不等待，我去做别的事情！比如响应UI事件、处理其他请求...&quot;</span>);</span><br><span class="line">    <span class="comment">// ... 在这里，主线程可以执行成千上万行其他代码 ...</span></span><br><span class="line">    <span class="comment">// ... 比如更新UI、计算另一个数据、响应用户点击 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在演示代码中，我们用 sleep 模拟主线程有其他工作要做，并防止程序提前退出</span></span><br><span class="line">    <span class="comment">// 在真实应用中，这里根本不会是 sleep()</span></span><br><span class="line">    <span class="comment">// Thread.sleep(6000); </span></span><br><span class="line">    System.out.println(<span class="string">&quot;主线程：我的其他工作都做完了，现在可以结束了。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程完成后就就被释放，而异步任务会被其它线程执行，异步任务结束后会触发回调，将由另外一个线程执行回调。</p>
<ul>
<li><strong>主线程的状态</strong>：<strong>非阻塞（Non-Blocked）&#x2F;运行（Running）</strong>。它提交任务后，立即继续执行 <code>System.out.println(&quot;主线程：不等待...&quot;)</code> 以及后续所有代码。它完全是自由的。</li>
<li><strong>资源高效利用</strong>：主线程（或请求处理线程）可以立即去服务下一个任务。这极大地提高了应用的<strong>吞吐量（Throughput）</strong>。</li>
</ul>
<p><strong>生活比喻</strong>：你去餐厅点餐，服务员给了你一个<strong>震动取餐器</strong>（<code>CompletableFuture</code>）。你<strong>不需要站在前台干等</strong>。你可以回到座位上玩手机、和朋友聊天（做其他工作）。当饭菜好了，取餐器震动（回调被触发），你再去取餐。你的时间被解放了。</p>
<hr>
<h4 id="关键区别总结：以-Web-服务器为例"><a href="#关键区别总结：以-Web-服务器为例" class="headerlink" title="关键区别总结：以 Web 服务器为例"></a>关键区别总结：以 Web 服务器为例</h4><p>这在 Web 服务器等高并发场景下，区别是<strong>天壤之别</strong>。</p>
<p>假设服务器有10个工作线程，一个请求需要5秒的数据库I&#x2F;O。</p>
<ul>
<li><p><strong>同步模式</strong>：</p>
<ol>
<li>第1个请求进来，占用线程1。线程1被<strong>阻塞5秒</strong>。</li>
<li>在这5秒内，如果又来了9个请求，它们会分别占用线程2到线程10，并全部被<strong>阻塞</strong>。</li>
<li>如果第11个请求进来，线程池已满，该请求只能排队等待，用户会感到明显的卡顿甚至超时。</li>
<li><strong>结论</strong>：10个线程最多只能<strong>同时处理10个</strong>这种慢请求。</li>
</ol>
</li>
<li><p><strong>异步模式</strong>：</p>
<ol>
<li>第1个请求进来，占用线程1。线程1提交一个异步DB查询后，<strong>立即被释放</strong>，回到线程池。</li>
<li>线程1可以<strong>立刻去处理第2个请求</strong>，同样提交异步查询后又被释放。</li>
<li>…以此类推，这10个线程可以非常快速地接收并提交<strong>成百上千个</strong>请求的初始部分。真正的等待发生在后台的I&#x2F;O操作上，而不是在宝贵的工作线程上。</li>
<li>当某个数据库查询完成后，线程池中的任何一个空闲线程都可以执行后续的回调（<code>thenAccept</code>），然后将结果返回给用户。</li>
<li><strong>结论</strong>：10个线程可以轻松应对<strong>远超10个</strong>的并发请求，极大地提升了服务的吞吐能力和响应性。</li>
</ol>
</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">同步模式</th>
<th align="left">异步模式 (<code>CompletableFuture</code>)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>主线程（或调用线程）</strong></td>
<td align="left"><strong>被阻塞</strong>，在原地等待任务完成。</td>
<td align="left"><strong>不被阻塞</strong>，提交任务后立即返回，可继续做其他事。</td>
</tr>
<tr>
<td align="left"><strong>资源利用率</strong></td>
<td align="left"><strong>低</strong>。线程在等待I&#x2F;O时被浪费。</td>
<td align="left"><strong>高</strong>。线程被解放出来去处理更多任务。</td>
</tr>
<tr>
<td align="left"><strong>程序吞吐量</strong></td>
<td align="left"><strong>低</strong>。受限于阻塞任务的数量。</td>
<td align="left"><strong>高</strong>。能同时处理大量并发I&#x2F;O密集型任务。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>所以，虽然最终整个<strong>程序（JVM进程）</strong>都需要存活到异步任务结束，但<strong>发起任务的那个线程</strong>却早已被解放。这就是异步回调与传统同步的根本区别和巨大优势。</p>
<h2 id="16-JMM"><a href="#16-JMM" class="headerlink" title="16. JMM"></a>16. JMM</h2><h3 id="1）对Volatile-的理解"><a href="#1）对Volatile-的理解" class="headerlink" title="1）对Volatile 的理解"></a>1）对Volatile 的理解</h3><p><strong>Volatile</strong> 是 Java 虚拟机提供 <strong>轻量级的同步机制</strong></p>
<p>保证可见性 - 确保变量修改对所有线程立即可见<br>不保证原子性 - 不能保证复合操作的原子性<br>禁止指令重排 - 防止编译器和处理器对代码进行重排序优化</p>
<p><strong>如何实现可见性</strong></p>
<p>volatile变量修饰的共享变量在进行写操作的时候回多出一行汇编：</p>
<p>0x01a3de1d:movb $0×0，0×1104800（%esi）;0x01a3de24**:lock** addl $0×0,(%esp);</p>
<p>Lock前缀的指令在多核处理器下会引发两件事情。</p>
<p>1）将当前处理器缓存行的数据写回到系统内存。</p>
<p>2）这个写回内存的操作会使其他cpu里缓存了该内存地址的数据无效。</p>
<p><strong>多处理器总线嗅探：</strong></p>
<p>​    为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存后再进行操作，但操作不知道何时会写到内存。如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是在<strong>多处理器下</strong>，为了保证各个处理器的缓存是一致的，就会实现缓存缓存一致性协议，<strong>每个处理器通过嗅探在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址呗修改，就会将当前处理器的缓存行设置无效状态</strong>，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据库读到处理器缓存中。</p>
<h3 id="2）什么是JMM？"><a href="#2）什么是JMM？" class="headerlink" title="2）什么是JMM？"></a>2）什么是JMM？</h3><p>JMM：JAVA内存模型，不存在的东西，是一个概念，也是一个约定！</p>
<p><strong>关于JMM的一些同步的约定：</strong><br><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250705210039990.png"><br>1、线程解锁前，必须把共享变量<strong>立刻</strong>刷回主存；</p>
<p>2、线程加锁前，必须<strong>读取主存</strong>中的最新值到工作内存中；</p>
<p>3、加锁和解锁是同一把锁；</p>
<p>线程中分为 <strong>工作内存、主内存</strong>   </p>
<p><strong>8种操作</strong>:</p>
<ul>
<li><p><strong>Read（读取）</strong>：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用；</p>
</li>
<li><p><strong>load（载入）</strong>：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中；</p>
</li>
<li><p><strong>Use（使用）</strong>：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令；</p>
</li>
<li><p><strong>assign（赋值）</strong>：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中；</p>
</li>
<li><p><strong>store（存储）</strong>：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用；</p>
</li>
<li><p><strong>write（写入）</strong>：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中；</p>
</li>
<li><p><strong>lock（锁定）</strong>：作用于主内存的变量，把一个变量标识为线程独占状态；</p>
</li>
<li><p><strong>unlock（解锁）</strong>：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定；</p>
<p><strong>JMM对这8种操作给了相应的规定</strong>：</p>
<ul>
<li>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write</li>
<li>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存</li>
<li>不允许一个线程将没有assign的数据从工作内存同步回主内存</li>
<li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过assign和load操作</li>
<li>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁</li>
<li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值</li>
<li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量</li>
<li>对一个变量进行unlock操作之前，必须把此变量同步回主内存</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.juc.testVolatile;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123; <span class="comment">// 主线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; <span class="comment">// 子线程</span></span><br><span class="line">            <span class="keyword">while</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 线程1一直在循环，直到num不等于0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>); <span class="comment">// 主线程休眠1秒</span></span><br><span class="line"></span><br><span class="line">        num = <span class="number">1</span>; <span class="comment">// 主线程将num设置为1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主线程修改了num的值，但是子线程并没有感知到这个变化，导致子线程一直在死循环。<br>需要让子线程知道主存中的num值已经被修改过了。</p>
<p><strong>程序不知道主存中的值已经被修改过了！</strong></p>
<h2 id="17-volatile"><a href="#17-volatile" class="headerlink" title="17. volatile"></a>17. volatile</h2><h3 id="1）保证可见性"><a href="#1）保证可见性" class="headerlink" title="1）保证可见性"></a>1）保证可见性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.juc.testVolatile;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="comment">// 不加volatile修饰符的变量, 导致线程1无法感知到主线程对num的修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123; <span class="comment">// 主线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; <span class="comment">// 线程1</span></span><br><span class="line">            <span class="keyword">while</span>(num == <span class="number">0</span>)&#123; <span class="comment">// 线程1对主存的变化不知道</span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>); <span class="comment">// 主线程休眠1秒</span></span><br><span class="line"></span><br><span class="line">        num = <span class="number">1</span>; <span class="comment">// 主线程将num设置为1</span></span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2）不保证原子性"><a href="#2）不保证原子性" class="headerlink" title="2）不保证原子性"></a>2）不保证原子性</h3><p>原子性：不可分割；</p>
<p>线程A在执行任务的时候，不能被打扰的，也不能被分割的，要么同时成功，要么同时失败。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.juc.testVolatile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">volatile</span>  <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 使用volatile修饰符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        num++; <span class="comment">// num++不是原子操作,读取变量 num 的当前值</span></span><br><span class="line">        <span class="comment">// 对值加 1</span></span><br><span class="line">        <span class="comment">// 将结果写回 num</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">2</span>]; <span class="comment">// 创建两个线程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)&#123;</span><br><span class="line">                    add(); <span class="comment">// 每个线程对num进行1000次自增操作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start(); <span class="comment">// 启动两个线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// while(Thread.activeCount() &gt; 2)&#123; // 默认有main和gc两个线程</span></span><br><span class="line">    <span class="comment">//     Thread.yield(); // yield()方法让当前线程让出CPU执行权，但当前线程仍然会被调度，不会等待其他线程结束</span></span><br><span class="line">        <span class="keyword">for</span>(Thread thread : threads)&#123;</span><br><span class="line">            thread.join(); <span class="comment">// 等待两个线程执行完毕</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出最终的num值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;最终的num值: &quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用volatile而不在add方法上加入synchronized修饰符，num++操作就不是原子操作，可能会出现线程安全问题，导致最终的num值不等于2000。</p>
<ul>
<li>join和yield的区别：</li>
</ul>
<ul>
<li><code>join()</code>：等待线程执行完毕，当前线程会阻塞，直到被调用的线程执行完毕。</li>
<li><code>yield()</code>：让出CPU执行权，当前线程仍然会被调度，不会等待其他线程结束。</li>
</ul>
<p><strong>如果不加lock或synchronized ，怎么样保证原子性？</strong></p>
<p><strong>使用原子类</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250706095804993.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VDemo02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">AtomicInteger</span> <span class="variable">number</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//        number++;</span></span><br><span class="line">        number.getAndIncrement();  <span class="comment">//底层是CAS保证的原子性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//理论上number  === 20000</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">1000</span> ; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//main  gc</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;,num=&quot;</span>+number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些类的底层都直接和操作系统挂钩！是在内存中修改值。</p>
<p>Unsafe类是一个很特殊的存在；</p>
<blockquote>
<p>原子类为什么这么高级？</p>
</blockquote>
<h3 id="3）禁止指令重排"><a href="#3）禁止指令重排" class="headerlink" title="3）禁止指令重排"></a>3）禁止指令重排</h3><p><strong>什么是指令重排？</strong></p>
<p>我们写的程序，计算机并不是按照我们自己写的那样去执行的</p>
<p>源代码–&gt;编译器优化重排–&gt;指令并行也可能会重排–&gt;内存系统也会重排–&gt;执行</p>
<p><strong>处理器在进行指令重排的时候，会考虑数据之间的依赖性！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">1</span>; <span class="comment">//1</span></span><br><span class="line"><span class="type">int</span> y=<span class="number">2</span>; <span class="comment">//2</span></span><br><span class="line">x=x+<span class="number">5</span>;   <span class="comment">//3</span></span><br><span class="line">y=x*x;   <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们期望的执行顺序是 1_2_3_4  可能执行的顺序会变成2134 1324</span></span><br><span class="line"><span class="comment">//可不可能是 4123？ 不可能的</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>可能造成的影响结果：前提：a b x y这四个值 默认都是0</p>
<table>
<thead>
<tr>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody><tr>
<td>x&#x3D;a</td>
<td>y&#x3D;b</td>
</tr>
<tr>
<td>b&#x3D;1</td>
<td>a&#x3D;2</td>
</tr>
</tbody></table>
<p>正常的结果： x &#x3D; 0; y &#x3D;0;</p>
<p>但是如果指令重排，可能会出现以下情况：<br>因为在线程A中，x和b没有数据依赖关系<br>线程B中，y和a没有数据依赖关系</p>
<table>
<thead>
<tr>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody><tr>
<td>b&#x3D;1</td>
<td>a&#x3D;2</td>
</tr>
<tr>
<td>x&#x3D;a</td>
<td>y&#x3D;b</td>
</tr>
</tbody></table>
<p>可能在线程A中会出现，先执行b&#x3D;1,然后再执行x&#x3D;a；</p>
<p>在B线程中可能会出现，先执行a&#x3D;2，然后执行y&#x3D;b；</p>
<p>那么就有可能结果如下：x&#x3D;2; y&#x3D;1.</p>
<p><strong>volatile可以避免指令重排：</strong></p>
<p><strong>volatile中会加一道内存的屏障，这个内存屏障可以保证在这个屏障中的指令顺序。</strong></p>
<p>内存屏障：CPU指令。作用：</p>
<p>1、保证特定的操作的执行顺序；</p>
<p>2、可以保证某些变量的内存可见性（利用这些特性，就可以保证volatile实现的可见性）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250706101747051.png"></p>
<p>当你在变量前加上 volatile 关键字时，JVM 会在对该变量的读写操作前后插入内存屏障（Memory Barrier）。内存屏障是一种 CPU 指令，用于限制指令的执行顺序。</p>
<p>好的，我们来对本次对话进行一个清晰的总结。</p>
<hr>
<h4 id="本次对话总结"><a href="#本次对话总结" class="headerlink" title="本次对话总结"></a>本次对话总结</h4><p>我们通过一张经典的并发问题图片，深入探讨了<code>volatile</code>关键字如何通过内存屏障解决指令重排问题。</p>
<h5 id="1-问题根源：指令重排-Instruction-Reordering"><a href="#1-问题根源：指令重排-Instruction-Reordering" class="headerlink" title="1. 问题根源：指令重排 (Instruction Reordering)"></a>1. 问题根源：指令重排 (Instruction Reordering)</h5><ul>
<li><strong>场景</strong>: 在一个多线程程序中（如图片所示的线程A和线程B），变量 <code>a, b, x, y</code> 初始值为0。<ul>
<li><strong>线程A</strong>: <code>x = a; b = 1;</code></li>
<li><strong>线程B</strong>: <code>y = b; a = 2;</code></li>
</ul>
</li>
<li><strong>问题</strong>: 为了提高性能，编译器和CPU在不影响<strong>单线程</strong>结果的情况下，可能会对没有数据依赖的指令进行重排。<ul>
<li>线程A的指令可能被重排为: <code>b = 1;</code> -&gt; <code>x = a;</code></li>
<li>线程B的指令可能被重排为: <code>a = 2;</code> -&gt; <code>y = b;</code></li>
</ul>
</li>
<li><strong>后果</strong>: 这种重排可能导致出现一个在逻辑上看似不可能的结果：<code>x = 2</code> 且 <code>y = 1</code>。</li>
</ul>
<h5 id="2-volatile-的解决方案"><a href="#2-volatile-的解决方案" class="headerlink" title="2. volatile 的解决方案"></a>2. <code>volatile</code> 的解决方案</h5><ul>
<li>将共享变量 <code>a</code> 和 <code>b</code> 声明为 <code>volatile</code> (<code>volatile int a = 0; volatile int b = 0;</code>)。</li>
<li><code>volatile</code> 关键字能解决这个问题，主要依靠它的两大作用：<ol>
<li><strong>保证可见性</strong>: 一个线程对<code>volatile</code>变量的修改，对其他线程是立即可见的。</li>
<li><strong>禁止指令重排</strong>: 这是解决本问题的核心。</li>
</ol>
</li>
</ul>
<h5 id="3-核心机制：内存屏障-Memory-Barrier"><a href="#3-核心机制：内存屏障-Memory-Barrier" class="headerlink" title="3. 核心机制：内存屏障 (Memory Barrier)"></a>3. 核心机制：内存屏障 (Memory Barrier)</h5><ul>
<li><code>volatile</code> 通过在底层操作中插入<strong>内存屏障</strong>来实现禁止指令重排。</li>
<li>内存屏障就像一道“栅栏”，它规定了：<ul>
<li>栅栏前的所有读写操作必须全部完成。</li>
<li>才能执行栅栏后的读写操作。</li>
<li>指令不能被重排到栅栏的另一边。</li>
</ul>
</li>
<li><strong>应用到本例中</strong>:<ul>
<li>当 <code>b</code> 是 <code>volatile</code> 时，<code>b = 1;</code> (volatile写) 会受到内存屏障的保护，它不能被重排到 <code>x = a;</code> 之前。</li>
<li>同理，<code>a = 2;</code> (volatile写) 也不能被重排到 <code>y = b;</code> 之前。</li>
<li>因此，两个线程的执行顺序都得到了保证，从而避免了异常结果的发生。</li>
</ul>
</li>
</ul>
<h5 id="4-关键点澄清-针对-x-a-和-y-b-的提问"><a href="#4-关键点澄清-针对-x-a-和-y-b-的提问" class="headerlink" title="4. 关键点澄清 (针对 x=a 和 y=b 的提问)"></a>4. 关键点澄清 (针对 <code>x=a</code> 和 <code>y=b</code> 的提问)</h5><ul>
<li><code>volatile</code> 的内存屏障规则是围绕<strong>被<code>volatile</code>修饰的变量</strong>的访问来建立的，而不是赋值符号<code>=</code>本身。</li>
<li>在 <code>x = a;</code> 这个操作中，虽然最终是<strong>写</strong>局部变量 <code>x</code>，但它首先需要**读取<code>volatile</code>变量<code>a</code>**。</li>
<li>正是这个对<code>volatile</code>变量<code>a</code>的<strong>读操作</strong>，触发了内存屏障机制，使得该语句的执行顺序被固定，不能随意移动。</li>
<li>同理，<code>y = b;</code> 中的对<code>volatile</code>变量<code>b</code>的<strong>读操作</strong>也受到了保护。</li>
</ul>
<p><strong>最终结论</strong>: <code>volatile</code>关键字是解决并发编程中变量可见性和指令重排问题的重要工具。它通过插入内存屏障，强制规定了内存操作的顺序，确保了多线程程序的执行结果与程序员的预期一致。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250706103638282.png"></p>
<h3 id="4）总结"><a href="#4）总结" class="headerlink" title="4）总结"></a>4）总结</h3><ul>
<li><strong>volatile可以保证可见性；</strong></li>
<li><strong>不能保证原子性</strong></li>
<li><strong>由于内存屏障，可以保证避免指令重排的现象产生</strong></li>
</ul>
<p>面试官：那么你知道在哪里用这个内存屏障用得最多呢？<strong>单例模式</strong></p>
<h2 id="18-玩转单例模式"><a href="#18-玩转单例模式" class="headerlink" title="18. 玩转单例模式"></a>18. 玩转单例模式</h2><h3 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h3><p>单例模式是一种非常常见的设计模式，它的核心思想很简单：确保一个类在任何情况下都绝对只有一个实例，并提供一个全局的访问点来获取这个实例。<br>你可以把它想象成一个国家只有一个总统，或者一个公司只有一个 CEO。无论你在公司的哪个部门，当你需要向 CEO 汇报时，你找到的都是同一个人，而不是每次都新“创建”一个 CEO。</p>
<h3 id="单例模式的好处"><a href="#单例模式的好处" class="headerlink" title="单例模式的好处"></a>单例模式的好处</h3><ul>
<li>节省资源：对于一些需要频繁创建和销毁的对象，比如数据库连接池、线程池等，创建一个实例的开销很大。单例模式可以确保只有一个实例在内存中，从而节省系统资源。</li>
<li>保证结果正确性：当一个类的功能需要依赖某些共享的状态或数据时，单例可以确保所有操作都作用于同一个实例，避免了数据不一致的问题。例如，一个网站的计数器，如果每次都 new 一个新对象，计数就永远无法累加。</li>
<li>提供全局访问点：可以方便地在程序的任何地方访问这个唯一的实例，就像一个全局变量，但比全局变量更安全、更易于管理。</li>
</ul>
<h3 id="如何实现单例模式"><a href="#如何实现单例模式" class="headerlink" title="如何实现单例模式"></a>如何实现单例模式</h3><ul>
<li><p><strong>私有化构造函数</strong> (Private Constructor)：<br>目的是为了防止外部通过 new 关键字随意创建对象。既然要保证唯一，就不能让别人随便创建。</p>
</li>
<li><p><strong>在类内部创建私有的静态实例</strong> (Private Static Instance)：<br>在类的内部自己创建一个实例。因为是 static 的，所以它与类绑定，是唯一的。</p>
</li>
<li><p><strong>提供一个公有的静态方法</strong> (Public Static Method)：<br>这个方法是外界获取这个唯一实例的入口，通常命名为 getInstance()。</p>
</li>
</ul>
<p><strong>常见的实现方式</strong></p>
<h3 id="1）饿汉式"><a href="#1）饿汉式" class="headerlink" title="1）饿汉式"></a>1）饿汉式</h3><p>迫不及待，类加载的时候就把实例常见好，不管用不用</p>
<ul>
<li><strong>优点</strong>：实现简单，代码清晰。由于实例是在类加载时创建的，由 JVM 保证了线程安全，不存在多线程同步问题。</li>
<li><strong>缺点</strong>：如果这个实例从未使用过，会造成内存浪费。它不是懒加载（Lazy Loading）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式：线程安全，但可能造成资源浪费</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 在类加载时就立即创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 私有化构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 提供公有的获取实例的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2）DCL懒汉式"><a href="#2）DCL懒汉式" class="headerlink" title="2）DCL懒汉式"></a>2）DCL懒汉式</h3><p>“懒汉” 就是非常懒，只有在第一次被用到的时候才去创建实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式单例模式</span></span><br><span class="line"><span class="keyword">package</span> com.example.juc.single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyDoubleCheck</span> &#123;</span><br><span class="line">    <span class="comment">// 静态变量 instance 用于存储单例实例，statci与类绑定</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyDoubleCheck instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyDoubleCheck</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (LazyDoubleCheck.class) &#123;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双重检查锁定（Double-Checked Locking）实现单例模式，避免每次都要同步锁，提高性能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyDoubleCheck <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次检查 instance 是否为 null</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (LazyDoubleCheck.class) &#123;</span><br><span class="line">                <span class="comment">// 第二次检查 instance 是否为 null</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果仍然为 null，则创建新的实例</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazyDoubleCheck</span>();</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     *  instance = new LazyDoubleCheck();并非原子操作</span></span><br><span class="line"><span class="comment">                     *  大概分为三步：：1. 分配内存；2. 初始化对象；3. 将 instance 引用指向分配的内存。</span></span><br><span class="line"><span class="comment">                     *  如果没有volatile修饰，可能会发生指令重排，导致第三步在第二步之前执行，此时另外一个线程发现instance不为null</span></span><br><span class="line"><span class="comment">                     *  但实际上对象还没有初始化完成，使用就会出错i。volatile可以防止这种重排</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>反射可以获取类的构造方法，并改变构造方法的权限从而创建实例。这个时候就需要在构造方法中判断当前实例是否已经存在，如果存在则抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.juc.single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyDoubleCheck</span> &#123;</span><br><span class="line">    <span class="comment">// 静态变量 instance 用于存储单例实例，statci与类绑定</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyDoubleCheck instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyDoubleCheck</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (LazyDoubleCheck.class) &#123;</span><br><span class="line">            <span class="comment">// 为了防止使用反射破坏单例模式，检查 instance 是否为 null</span></span><br><span class="line">            <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不要试图利用反射破坏单例模式&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双重检查锁定（Double-Checked Locking）实现单例模式，避免每次都要同步锁，提高性能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyDoubleCheck <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次检查 instance 是否为 null</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (LazyDoubleCheck.class) &#123;</span><br><span class="line">                <span class="comment">// 第二次检查 instance 是否为 null</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果仍然为 null，则创建新的实例</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazyDoubleCheck</span>();</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     *  instance = new LazyDoubleCheck();并非原子操作</span></span><br><span class="line"><span class="comment">                     *  大概分为三步：：1. 分配内存；2. 初始化对象；3. 将 instance 引用指向分配的内存。</span></span><br><span class="line"><span class="comment">                     *  如果没有volatile修饰，可能会发生指令重排，导致第三步在第二步之前执行，此时另外一个线程发现instance不为null</span></span><br><span class="line"><span class="comment">                     *  但实际上对象还没有初始化完成，使用就会出错i。volatile可以防止这种重排</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反射可以破解单例模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">LazyDoubleCheck</span> <span class="variable">instance1</span> <span class="operator">=</span> LazyDoubleCheck.getInstance();</span><br><span class="line">        <span class="comment">// 获取空参构造器</span></span><br><span class="line">        Constructor&lt;LazyDoubleCheck&gt; declaredConstructor = LazyDoubleCheck.class.getDeclaredConstructor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置可访问性</span></span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射创建实例</span></span><br><span class="line">        <span class="type">LazyDoubleCheck</span> <span class="variable">instance2</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(instance1 == instance2); <span class="comment">// 输出 false，说明是不同的实例</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在从双重检测升级了三重检测<br>但如果从始至终都使用getInstance()方法获取实例，只用反射创建实例，三重检测就会失效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// LazyDoubleCheck instance1 = LazyDoubleCheck.getInstance();</span></span><br><span class="line">        <span class="comment">// 获取空参构造器</span></span><br><span class="line">        Constructor&lt;LazyDoubleCheck&gt; declaredConstructor = LazyDoubleCheck.class.getDeclaredConstructor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置可访问性</span></span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射创建实例</span></span><br><span class="line">        <span class="type">LazyDoubleCheck</span> <span class="variable">instance2</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="type">LazyDoubleCheck</span> <span class="variable">instance3</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(instance2 == instance3); <span class="comment">// 输出 false，说明是不同的实例</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>两个实例都是利用反射创建的对象</strong></p>
<p><strong>引入变量确保构造方法只能构造一次</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.juc.single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyDoubleCheck</span> &#123;</span><br><span class="line">    <span class="comment">// 静态变量 instance 用于存储单例实例，statci与类绑定</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyDoubleCheck instance;</span><br><span class="line">    <span class="comment">// 引入一个变量，确保构造方法只能被调用一次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyDoubleCheck</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">        <span class="comment">// 为了防止使用反射破坏单例模式，检查 instance 是否为 null</span></span><br><span class="line">        <span class="keyword">synchronized</span> (LazyDoubleCheck.class) &#123;</span><br><span class="line">            <span class="comment">// 为了防止使用反射破坏单例模式，检查 instance 是否为 null</span></span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="literal">false</span>) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果已经被实例化，则抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不要试图利用反射破坏单例模式&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双重检查锁定（Double-Checked Locking）实现单例模式，避免每次都要同步锁，提高性能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyDoubleCheck <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次检查 instance 是否为 null</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (LazyDoubleCheck.class) &#123;</span><br><span class="line">                <span class="comment">// 第二次检查 instance 是否为 null</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果仍然为 null，则创建新的实例</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazyDoubleCheck</span>();</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     *  instance = new LazyDoubleCheck();并非原子操作</span></span><br><span class="line"><span class="comment">                     *  大概分为三步：：1. 分配内存；2. 初始化对象；3. 将 instance 引用指向分配的内存。</span></span><br><span class="line"><span class="comment">                     *  如果没有volatile修饰，可能会发生指令重排，导致第三步在第二步之前执行，此时另外一个线程发现instance不为null</span></span><br><span class="line"><span class="comment">                     *  但实际上对象还没有初始化完成，使用就会出错i。volatile可以防止这种重排</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反射可以破解单例模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// LazyDoubleCheck instance1 = LazyDoubleCheck.getInstance();</span></span><br><span class="line">        <span class="comment">// 获取空参构造器</span></span><br><span class="line">        Constructor&lt;LazyDoubleCheck&gt; declaredConstructor = LazyDoubleCheck.class.getDeclaredConstructor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置可访问性</span></span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射创建实例</span></span><br><span class="line">        <span class="type">LazyDoubleCheck</span> <span class="variable">instance2</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="type">LazyDoubleCheck</span> <span class="variable">instance3</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(instance2 == instance3); <span class="comment">// 输出 false，说明是不同的实例</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>加密就会有解密，如果别人知道我们的变量，依旧可以利用反射破坏单例模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// LazyDoubleCheck instance1 = LazyDoubleCheck.getInstance();</span></span><br><span class="line">        <span class="comment">// 获取空参构造器</span></span><br><span class="line">        Constructor&lt;LazyDoubleCheck&gt; declaredConstructor = LazyDoubleCheck.class.getDeclaredConstructor();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置可访问性</span></span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取字段</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">declaredField</span> <span class="operator">=</span> LazyDoubleCheck.class.getDeclaredField(<span class="string">&quot;flag&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置可访问性</span></span><br><span class="line">        declaredField.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射创建实例</span></span><br><span class="line">        <span class="type">LazyDoubleCheck</span> <span class="variable">instance2</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line"></span><br><span class="line">        declaredField.set(instance2,<span class="literal">false</span>); <span class="comment">// 设置 flag 为 false</span></span><br><span class="line"></span><br><span class="line">        <span class="type">LazyDoubleCheck</span> <span class="variable">instance3</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(instance2 == instance3); <span class="comment">// 输出 false，说明是不同的实例</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>道高一尺，魔高一丈</p>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250706161641757.png"><br>java的反射不能破坏枚举的单例模式  </p>
<h3 id="3）静态内部类"><a href="#3）静态内部类" class="headerlink" title="3）静态内部类"></a>3）静态内部类</h3><blockquote>
<p>静态内部类实现单例模式仍然会被反射破坏</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Holder</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Holder <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.holder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Holder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Holder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样可以使用反射得到无参构造方法并修改权限获取实例</p>
<blockquote>
<p>单例不安全, 因为反射</p>
</blockquote>
<h3 id="4）枚举"><a href="#4）枚举" class="headerlink" title="4）枚举"></a>4）枚举</h3><blockquote>
<p>Java 的枚举类型（enum）天生就是单例模式。<br>每个枚举常量（如 INSTANCE）在 JVM 中只会被实例化一次，并且由 Java 保证线程安全和反序列化时的单例性。因此，使用枚举实现单例模式是最简单且最安全的方式之一。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//enum 是什么？ enum本身就是一个Class 类</span></span><br><span class="line"><span class="keyword">package</span> com.example.juc.single;</span><br><span class="line"><span class="comment">// 枚举本身也是一个Class类</span></span><br><span class="line"><span class="comment">// 枚举类默认就是单例模式</span></span><br><span class="line"><span class="comment">// 每个枚举常量在JVM中只会被实例化一次</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingle</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EnumSingle</span> <span class="variable">instance1</span> <span class="operator">=</span> EnumSingle.INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="type">EnumSingle</span> <span class="variable">instance2</span> <span class="operator">=</span> EnumSingle.INSTANCE;</span><br><span class="line">        System.out.println(instance1 == instance2); <span class="comment">// 输出 true，说明是同一个实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看枚举类的编译后的字节码文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Source code is decompiled from a .class file using FernFlower decompiler.</span></span><br><span class="line"><span class="keyword">package</span> com.example.juc.single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingle</span> &#123;</span><br><span class="line">   INSTANCE;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">EnumSingle</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到里面有一个私有的无参构造方法<br>尝试用反射获取无参构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.juc.single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingle</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">EnumSingle</span> <span class="variable">instance1</span> <span class="operator">=</span> EnumSingle.INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// EnumSingle instance2 = EnumSingle.INSTANCE;</span></span><br><span class="line">        <span class="comment">// System.out.println(instance1 == instance2); // 输出 true，说明是同一个实例</span></span><br><span class="line"></span><br><span class="line">        Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(<span class="literal">null</span>);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 通过反射创建实例</span></span><br><span class="line">        <span class="type">EnumSingle</span> <span class="variable">instance2</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(instance1);</span><br><span class="line">        System.out.println(instance2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>报错如下<br><code>Exception in thread &quot;main&quot; java.lang.NoSuchMethodException: com.example.juc.single.EnumSingle.&lt;init&gt;()         at java.base/java.lang.Class.getConstructor0(Class.java:3585)         at java.base/java.lang.Class.getDeclaredConstructor(Class.java:2754)         at com.example.juc.single.Test.main(EnumSingle.java:18)</code></p>
<p>意思是枚举类型没有这个空参构造方法</p>
<p>只要有空参的构造方法的都是骗了我们</p>
<p>使用专业工具jad将class文件反编译为java文件</p>
<p>枚举类型的最终反编译源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">EnumSingle</span> <span class="keyword">extends</span> <span class="title class_">Enum</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EnumSingle[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (EnumSingle[])$VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EnumSingle <span class="title function_">valueOf</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (EnumSingle)Enum.valueOf(com/ogj/single/EnumSingle, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EnumSingle</span><span class="params">(String s, <span class="type">int</span> i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EnumSingle <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EnumSingle INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EnumSingle $VALUES[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> <span class="title class_">EnumSingle</span>(<span class="string">&quot;INSTANCE&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        $VALUES = (<span class="keyword">new</span> <span class="title class_">EnumSingle</span>[] &#123;</span><br><span class="line">            INSTANCE</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到里面的构造器是有参构造器</p>
<p>那么使用有参构造器获取实例化会怎么样呢</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.juc.single;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举本身也是一个Class类</span></span><br><span class="line"><span class="comment">// 枚举类默认就是单例模式</span></span><br><span class="line"><span class="comment">// 每个枚举常量在JVM中只会被实例化一次</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingle</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">EnumSingle</span> <span class="variable">instance1</span> <span class="operator">=</span> EnumSingle.INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// EnumSingle instance2 = EnumSingle.INSTANCE;</span></span><br><span class="line">        <span class="comment">// System.out.println(instance1 == instance2); // 输出 true，说明是同一个实例</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(null);</span></span><br><span class="line">        <span class="comment">// 获取有参构造器</span></span><br><span class="line">        Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 通过反射创建实例</span></span><br><span class="line">        <span class="type">EnumSingle</span> <span class="variable">instance2</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(instance1);</span><br><span class="line">        System.out.println(instance2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Cannot reflectively create enum objects</span><br><span class="line">        at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:493)</span><br><span class="line">        at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:481)</span><br><span class="line">        at com.example.juc.single.Test.main(EnumSingle.java:23)</span><br></pre></td></tr></table></figure>
<p>意思是不能反射创建枚举对象,正是我我们之前在newInstance方法中见到的，不能使用反射破坏枚举的单例模式。</p>
<h4 id="枚举类单例模式实用场景"><a href="#枚举类单例模式实用场景" class="headerlink" title="枚举类单例模式实用场景"></a>枚举类单例模式实用场景</h4><ol>
<li><strong>配置管理</strong>：如前面提到的 <code>AppConfig</code>，用于加载和提供应用的配置信息。</li>
<li><strong>日志管理</strong>：一个全局的日志管理器，负责记录应用的日志信息。</li>
<li><strong>线程池管理</strong>：一个全局的线程池，供整个应用共享使用。</li>
<li><strong>数据库连接池</strong>：一个全局的数据库连接池，管理数据库连接的创建和释放。</li>
</ol>
<p>在实际开发中，我们通常需要单例来管理一些共享的资源或状态。下面通过一个具体的例子来说明。</p>
<p>好的，完全没有问题。</p>
<p>这是一个使用<strong>枚举类</strong>创建<strong>线程池单例</strong>的伪代码，它清晰地展示了其核心结构和思想。</p>
<h4 id="场景：全局异步任务处理器"><a href="#场景：全局异步任务处理器" class="headerlink" title="场景：全局异步任务处理器"></a>场景：全局异步任务处理器</h4><p>在应用中，我们需要一个全局唯一的线程池来处理各种异步任务，如发送邮件、记录日志、处理文件等，以避免重复创建线程带来的资源浪费。</p>
<hr>
<h5 id="1-线程池单例的伪代码"><a href="#1-线程池单例的伪代码" class="headerlink" title="1. 线程池单例的伪代码"></a>1. 线程池单例的伪代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 使用枚举定义线程池管理器，这本身就是单例</span><br><span class="line">ENUM ThreadPoolManager:</span><br><span class="line">    </span><br><span class="line">    // 这是唯一的实例。JVM会保证它只被创建一次。</span><br><span class="line">    INSTANCE</span><br><span class="line"></span><br><span class="line">    // 私有成员变量，用于持有真正的线程池对象</span><br><span class="line">    PRIVATE FINAL thread_pool</span><br><span class="line"></span><br><span class="line">    // 构造函数：在INSTANCE被创建时自动调用，且仅调用一次</span><br><span class="line">    CONSTRUCTOR ThreadPoolManager():</span><br><span class="line">        // 1. 定义线程池的配置参数</span><br><span class="line">        core_threads = 4</span><br><span class="line">        max_threads = 10</span><br><span class="line">        task_queue = new Queue(capacity: 100)</span><br><span class="line"></span><br><span class="line">        // 2. 创建线程池实例</span><br><span class="line">        this.thread_pool = CREATE_THREAD_POOL(</span><br><span class="line">            core_size: core_threads,</span><br><span class="line">            max_size: max_threads,</span><br><span class="line">            queue: task_queue</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        // 3. (可选但推荐) 注册一个程序关闭时的钩子，用于优雅地关闭线程池</span><br><span class="line">        REGISTER_SHUTDOWN_HOOK(FUNCTION() &#123;</span><br><span class="line">            PRINT &quot;Application shutting down, closing thread pool...&quot;</span><br><span class="line">            this.thread_pool.SHUTDOWN_GRACEFULLY()</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    // 公共方法：提供给外部提交任务的接口</span><br><span class="line">    PUBLIC FUNCTION execute(task):</span><br><span class="line">        IF task IS NOT NULL:</span><br><span class="line">            this.thread_pool.SUBMIT(task)</span><br><span class="line">        ELSE:</span><br><span class="line">            PRINT_ERROR &quot;Submitted task is null.&quot;</span><br><span class="line"></span><br><span class="line">END ENUM</span><br></pre></td></tr></table></figure>

<h5 id="2-在应用不同模块中使用该单例的伪代码"><a href="#2-在应用不同模块中使用该单例的伪代码" class="headerlink" title="2. 在应用不同模块中使用该单例的伪代码"></a>2. 在应用不同模块中使用该单例的伪代码</h5><p><strong>用户服务模块 (UserService):</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CLASS UserService:</span><br><span class="line">    </span><br><span class="line">    FUNCTION register_user(email):</span><br><span class="line">        // 同步执行数据库插入</span><br><span class="line">        SAVE_USER_TO_DB(email)</span><br><span class="line">        </span><br><span class="line">        // 创建一个异步任务：发送欢迎邮件</span><br><span class="line">        send_email_task = FUNCTION():</span><br><span class="line">            SLEEP(2 seconds) // 模拟耗时</span><br><span class="line">            SEND_EMAIL(to: email, subject: &quot;Welcome!&quot;)</span><br><span class="line">        </span><br><span class="line">        // 将任务提交给全局唯一的线程池</span><br><span class="line">        ThreadPoolManager.INSTANCE.execute(send_email_task)</span><br><span class="line">        </span><br><span class="line">        PRINT &quot;User registration complete. Welcome email will be sent in background.&quot;</span><br><span class="line"></span><br><span class="line">END CLASS</span><br></pre></td></tr></table></figure>

<p><strong>文件处理模块 (FileProcessor):</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CLASS FileProcessor:</span><br><span class="line"></span><br><span class="line">    FUNCTION process_file(file_path):</span><br><span class="line">        // 创建一个异步任务：处理文件</span><br><span class="line">        process_file_task = FUNCTION():</span><br><span class="line">            SLEEP(5 seconds) // 模拟耗时</span><br><span class="line">            COMPRESS_FILE(file_path)</span><br><span class="line">            GENERATE_THUMBNAIL(file_path)</span><br><span class="line"></span><br><span class="line">        // 同样将任务提交给那个全局唯一的线程池</span><br><span class="line">        ThreadPoolManager.INSTANCE.execute(process_file_task)</span><br><span class="line">        </span><br><span class="line">        PRINT &quot;File processing started in background for: &quot; + file_path</span><br><span class="line"></span><br><span class="line">END CLASS</span><br></pre></td></tr></table></figure>

<h5 id="3-主程序流程伪代码"><a href="#3-主程序流程伪代码" class="headerlink" title="3. 主程序流程伪代码"></a>3. 主程序流程伪代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION main():</span><br><span class="line">    user_service = new UserService()</span><br><span class="line">    file_processor = new FileProcessor()</span><br><span class="line">    </span><br><span class="line">    // 触发用户注册，这将向线程池提交一个任务</span><br><span class="line">    // 在这里，ThreadPoolManager的构造函数会被第一次调用，并创建线程池</span><br><span class="line">    user_service.register_user(&quot;test@example.com&quot;)</span><br><span class="line">    </span><br><span class="line">    // 触发文件处理，向同一个线程池提交另一个任务</span><br><span class="line">    // 此时，直接复用已存在的线程池，构造函数不会再次执行</span><br><span class="line">    file_processor.process_file(&quot;/path/to/my_report.pdf&quot;)</span><br><span class="line">    </span><br><span class="line">    PRINT &quot;Main thread is free to do other work.&quot;</span><br><span class="line">    // ...主线程继续执行...</span><br><span class="line"></span><br><span class="line">END FUNCTION</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="伪代码核心思想"><a href="#伪代码核心思想" class="headerlink" title="伪代码核心思想"></a>伪代码核心思想</h5><ol>
<li><strong><code>ThreadPoolManager.INSTANCE</code></strong> 是全局唯一的访问点。</li>
<li><strong>构造函数只执行一次</strong>，在其中完成线程池的复杂初始化和配置。</li>
<li>任何模块（如 <code>UserService</code>、<code>FileProcessor</code>）都通过 <code>ThreadPoolManager.INSTANCE.execute()</code> 来提交任务，它们共享着同一个线程池资源。</li>
<li>资源的管理（如创建和关闭）被封装在单例内部，对使用者透明，降低了使用复杂度。</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><code>INSTANCE</code> 是你为这个<strong>唯一的、全局可访问的枚举实例</strong>起的名字。</li>
<li>在实际开发中，你将<strong>状态和行为</strong>（即成员变量和方法）添加到这个枚举类中。</li>
<li>通过 <code>你的枚举类名.INSTANCE</code> 这种方式在程序的任何地方安全地、方便地访问这个唯一的实例及其方法。</li>
<li>这种方式是实现单例的<strong>最推荐、最安全、最简洁</strong>的方式。</li>
</ul>
<h2 id="19-深入理解CAS"><a href="#19-深入理解CAS" class="headerlink" title="19. 深入理解CAS"></a>19. 深入理解CAS</h2><h3 id="1）什么是CAS？"><a href="#1）什么是CAS？" class="headerlink" title="1）什么是CAS？"></a>1）什么是CAS？</h3><p>大厂必须深入研究底层！！！！<strong>修内功！操作系统、计算机网络原理、组成原理、数据结构</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">casDemo</span> &#123;</span><br><span class="line">    <span class="comment">//// CAS（Compare-And-Set）操作：比较当前工作内存的值和主内存的值，若这个值是期望则执行，如果不是就一直循环</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">2020</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//boolean compareAndSet(int expect, int update)</span></span><br><span class="line">        <span class="comment">//期望值、更新值</span></span><br><span class="line">        <span class="comment">//如果实际值 和 我的期望值相同，那么就更新</span></span><br><span class="line">        <span class="comment">//如果实际值 和 我的期望值不同，那么就不更新</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>, <span class="number">2021</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为期望值是2020  实际值却变成了2021  所以会修改失败</span></span><br><span class="line">        <span class="comment">//CAS 是CPU的并发原语</span></span><br><span class="line">        atomicInteger.getAndIncrement(); <span class="comment">//++操作</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>, <span class="number">2021</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Unsafe 类<br>进入compareAndSet方法<br>查看U发现是Unsafe类<br><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250708102609039.png"></p>
<p>查看Unsafe类中的compareAndSetInt方法<br><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250708103103123.png"></p>
<p>compareAndSetInt方法是内存操作，效率很高</p>
<p>getAndIncrement()<br><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250708104145218.png"></p>
<p>可以看到不能更新成功就一直循环，这就是自旋锁</p>
<h3 id="2）总结"><a href="#2）总结" class="headerlink" title="2）总结"></a>2）总结</h3><p>CAS：比较当前工作内存中的值 和 主内存中的值，如果这个值是期望的，那么则执行操作！如果不是就一直循环，使用的是自旋锁。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>循环会耗时；</li>
<li>一次性只能保证一个共享变量的原子性；</li>
<li>它会存在ABA问题</li>
</ul>
<blockquote>
<p>CAS：ABA问题？(狸猫换太子)</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250708143943997.png"><br>线程1：期望值是1，要变成2；</p>
<p>线程2：两个操作：</p>
<ul>
<li>1、期望值是1，变成3</li>
<li>2、期望是3，变成1</li>
</ul>
<p>线程2先把两个操作完成，线程1期望是1，现在也是1，但不是原来的1，而是线程2操作过的1；<br>即线程1被骗过了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">casDemo</span> &#123;</span><br><span class="line">    <span class="comment">//CAS : compareAndSet 比较并交换</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">2020</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>, <span class="number">2021</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//boolean compareAndSet(int expect, int update)</span></span><br><span class="line">        <span class="comment">//期望值、更新值</span></span><br><span class="line">        <span class="comment">//如果实际值 和 我的期望值相同，那么就更新</span></span><br><span class="line">        <span class="comment">//如果实际值 和 我的期望值不同，那么就不更新</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2021</span>, <span class="number">2020</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为期望值是2020  实际值却变成了2021  所以会修改失败</span></span><br><span class="line">        <span class="comment">//CAS 是CPU的并发原语</span></span><br><span class="line"><span class="comment">//        atomicInteger.getAndIncrement(); //++操作</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>, <span class="number">2021</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="20-原子引用"><a href="#20-原子引用" class="headerlink" title="20. 原子引用"></a>20. 原子引用</h2><blockquote>
<p>解决ABA问题，对应的思想：就是使用了<strong>乐观锁~</strong></p>
</blockquote>
<p>带版本号的 原子操作！</p>
<p>其实就是乐观锁的思路，判断修改的时候判断版本号即可</p>
<p><strong>Integer 使用了对象缓存机制，默认范围是-128~127，推荐使用静态工厂方法valueOf获取对象实例，而不是new，因为valueOf使用缓存，而new一定会创建新的对象分配新的内存空间。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250708152324295.png"></p>
<p><strong>带版本号的原子操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.juc.cas;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CasDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        AtomicStampedReference &lt;Integer&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicReference.getStamp(); <span class="comment">// a1 = 1</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a1=&gt;&quot;</span> + stamp);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>); <span class="comment">// 模拟线程1等待</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">result1</span> <span class="operator">=</span> atomicReference.compareAndSet(<span class="number">1</span>, <span class="number">3</span>, atomicReference.getStamp(), atomicReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a2=&gt;&quot;</span>+ atomicReference.getStamp()); <span class="comment">// a2 = 2</span></span><br><span class="line">            System.out.println(<span class="string">&quot;result1&quot;</span>+result1); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> result2=atomicReference.compareAndSet(<span class="number">3</span>, <span class="number">1</span>, atomicReference.getStamp(), atomicReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;result2&quot;</span>+result2); <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a3=&gt;&quot;</span>+atomicReference.getStamp());<span class="comment">//a3 = 3</span></span><br><span class="line">            </span><br><span class="line">        &#125;,<span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicReference.getStamp();</span><br><span class="line">            System.out.println(<span class="string">&quot;b1=&gt;&quot;</span>+stamp); <span class="comment">// b1 = 1</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最初的版本号stamp是1，但当线程a修改了值后，版本号变成了3，导致与期望版本号1不一致则修改失败</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> atomicReference.compareAndSet(<span class="number">1</span>, <span class="number">5</span>, stamp, stamp+<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;result&quot;</span>+result); <span class="comment">// false</span></span><br><span class="line">            System.out.println(atomicReference.getStamp());<span class="comment">// 3</span></span><br><span class="line">        &#125;,<span class="string">&quot;b&quot;</span>).start();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p><strong>坑点</strong> </p>
<p>如果我把值修初始值修改为很大，那么修改结果将都为false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.juc.cas;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CasDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        AtomicStampedReference &lt;Integer&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">2021</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicReference.getStamp(); <span class="comment">// a1 = 1</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a1=&gt;&quot;</span> + stamp);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>); <span class="comment">// 模拟线程1等待</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">result1</span> <span class="operator">=</span> atomicReference.compareAndSet(<span class="number">2021</span>, <span class="number">2022</span>, atomicReference.getStamp(), atomicReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a2=&gt;&quot;</span>+ atomicReference.getStamp()); <span class="comment">// a2 = 2</span></span><br><span class="line">            System.out.println(<span class="string">&quot;result1&quot;</span>+result1); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> result2=atomicReference.compareAndSet(<span class="number">2022</span>, <span class="number">2021</span>, atomicReference.getStamp(), atomicReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;result2&quot;</span>+result2); <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a3=&gt;&quot;</span>+atomicReference.getStamp());<span class="comment">//a3 = 3</span></span><br><span class="line">            </span><br><span class="line">        &#125;,<span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicReference.getStamp();</span><br><span class="line">            System.out.println(<span class="string">&quot;b1=&gt;&quot;</span>+stamp); <span class="comment">// b1 = 1</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> atomicReference.compareAndSet(<span class="number">2021</span>, <span class="number">2023</span>, stamp, stamp+<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;result&quot;</span>+result); <span class="comment">// false</span></span><br><span class="line">            System.out.println(atomicReference.getStamp());<span class="comment">// 3</span></span><br><span class="line">        &#125;,<span class="string">&quot;b&quot;</span>).start();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p><strong>原因分析</strong><br>首先我们当前的引用的对象是Integer<br>查看源码<br>compareAndSet<br><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250708160257018.png"></p>
<p>使用的是 <strong>&#x3D;&#x3D;</strong> 进行比较，对于基本数据类型，比较的是值，对于引用类型，比较的是地址值</p>
<p>Integer是引用数据类型，并且存在缓存机制。</p>
<p>当Integer的范围处于-128~127之间时，会触发缓存机制，并不会创建新的对象。</p>
<p>而我们的值是2021和2022，每次都是新的对象，所以会比较失败。</p>
<p>因此实际中，通常不使用直接的包装类型作为泛型，而是自定义包装类型，并在原对象中操作。</p>
<h2 id="21-各种锁的理解"><a href="#21-各种锁的理解" class="headerlink" title="21. 各种锁的理解"></a>21. 各种锁的理解</h2><h3 id="1）公平锁，非公平锁"><a href="#1）公平锁，非公平锁" class="headerlink" title="1）公平锁，非公平锁"></a>1）公平锁，非公平锁</h3><ol>
<li><p>公平锁：非常公平，不能插队，必须先来后到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment">     * given fairness policy.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>非公平锁：非常不公平，允许插队，可以改变顺序</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized 和 ReentrantLock 默认都是非公平锁。</p>
<h3 id="2）可重入锁-递归锁"><a href="#2）可重入锁-递归锁" class="headerlink" title="2）可重入锁(递归锁)"></a>2）可重入锁(递归锁)</h3><p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250708162134105.png"></p>
<p>可重入锁是指同一个线程可以多次获取同一把锁而不会发生死锁的情况。<br>上锁与解锁成对出现</p>
<ol>
<li>Synchonized 锁</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sms</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt; sms&quot;</span>);</span><br><span class="line">        call();<span class="comment">//这里也有一把锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt; call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A=&gt; sms</span><br><span class="line">A=&gt; call</span><br><span class="line">B=&gt; sms</span><br><span class="line">B=&gt; call</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Lock 锁</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lock</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone2</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone2</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone2</span>&#123;</span><br><span class="line"></span><br><span class="line">    Lock lock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sms</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock(); <span class="comment">//细节：这个是两把锁，两个钥匙</span></span><br><span class="line">        <span class="comment">//lock锁必须配对，否则就会死锁在里面</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt; sms&quot;</span>);</span><br><span class="line">            call();<span class="comment">//这里也有一把锁</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt; call&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>lock锁必须配对，相当于lock和 unlock 必须数量相同；</li>
<li>在外面加的锁，也可以在里面解锁；在里面加的锁，在外面也可以解锁；</li>
</ul>
<h3 id="3）自旋锁"><a href="#3）自旋锁" class="headerlink" title="3）自旋锁"></a>3）自旋锁</h3><blockquote>
<p>一直尝试直到成功</p>
</blockquote>
<ol>
<li>spinlock</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>自我设计自旋锁</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinlockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认</span></span><br><span class="line">    <span class="comment">// int 0</span></span><br><span class="line">    <span class="comment">//thread null</span></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference=<span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加锁 ,使用线程作为锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myLock</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(thread.getName()+<span class="string">&quot;===&gt; mylock&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//AtomicReference的compareAndSet方法是比较值</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">lockAcquired</span> <span class="operator">=</span> atomicReference.compareAndSet(<span class="literal">null</span>, thread);</span><br><span class="line">        <span class="keyword">while</span>(!lockAcquired)&#123;</span><br><span class="line">            <span class="comment">//如果当前线程没有获取到锁，就一直自旋等待</span></span><br><span class="line">            System.out.println(thread.getName()+<span class="string">&quot;===&gt; 自旋等待&quot;</span>);</span><br><span class="line">            lockAcquired = atomicReference.compareAndSet(<span class="literal">null</span>, thread);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(thread.getName()+<span class="string">&quot;===&gt; 获取锁成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解锁，将当前线程从atomicReference中移除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myUnlock</span><span class="params">()</span>&#123;</span><br><span class="line">        Thread thread=Thread.currentThread();</span><br><span class="line">        System.out.println(thread.getName()+<span class="string">&quot;===&gt; myUnlock&quot;</span>);</span><br><span class="line">        atomicReference.compareAndSet(thread,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSpinLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ReentrantLock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        reentrantLock.unlock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用CAS实现自旋锁</span></span><br><span class="line">        SpinlockDemo spinlockDemo=<span class="keyword">new</span> <span class="title class_">SpinlockDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            spinlockDemo.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                spinlockDemo.myUnlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            spinlockDemo.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                spinlockDemo.myUnlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4）死锁"><a href="#4）死锁" class="headerlink" title="4）死锁"></a>4）死锁</h3><p>在多线程编程中，我们为了防止多线程竞争共享资源而导致数据错乱，都会在操作共享资源之前加上互斥锁，只有成功获得到锁的线程，才能操作共享资源，获取不到锁的线程就只能等待，直到锁被释放<br>当两个线程为了保护两个不同的共享资源而使用了两个互斥锁，那么这两个互斥锁应用不当的时候，可能会造成两个线程都在等待对方释放锁，在没有外力的作用下，这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了死锁。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250708170802743.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.juc.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;Thread-1&quot;</span>, lock1, lock2);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;Thread-2&quot;</span>, lock2, lock1);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Object lock1;</span><br><span class="line">    <span class="keyword">private</span> Object lock2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name, Object lock1, Object lock2)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.lock1 = lock1;</span><br><span class="line">        <span class="built_in">this</span>.lock2 = lock2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot; acquired lock on &quot;</span> + lock1);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟一些工作</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot; acquired lock on &quot;</span> + lock2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何解开死锁</p>
<p><strong>1、使用jps定位进程号，jdk的bin目录下： 有一个jps</strong></p>
<p>命令：<code>jps -l</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250708172924688.png"></p>
<p><strong>2、使用<code>jstack</code> 进程进程号 找到死锁信息</strong></p>
<p><strong>一般情况信息在最后：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Cxhahalala/hexo-images-1@main/images/20250708172950308.png"></p>
<p><strong>日志</strong></p>
<p><strong>堆栈信息</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://cxhahalala.github.io">Cx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://cxhahalala.github.io/posts/java/juc/">https://cxhahalala.github.io/posts/java/juc/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://cxhahalala.github.io" target="_blank">Cx`s Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post-share"><div class="social-share" data-image="https://w.wallhaven.cc/full/je/wallhaven-je8q9w.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/posts/redis/redis-feed-stream/" title="Feed流"><img class="cover" src="https://w.wallhaven.cc/full/5y/wallhaven-5yddx3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Feed流</div></div><div class="info-2"><div class="info-item-1">Feed流是一种为用户持续提供内容的推送机制,本文详细介绍Feed流的两种实现模式：拉模式、推模式和推拉结合模式...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/redis/redis-bitmap/" title="利用Redis的BitMap实现用户签到功能"><img class="cover" src="https://w.wallhaven.cc/full/w5/wallhaven-w5o7r6.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-17</div><div class="info-item-2">利用Redis的BitMap实现用户签到功能</div></div><div class="info-2"><div class="info-item-1">Redis的BitMap结结构，利用此结构实现用户签到功能  BitMap功能演示传统方案的问题我们针对签到功能完全可以通过MySQL来完成，比如说以下这张表： 存储成本分析：  用户一次签到，就是一条记录 假如有1000万用户，平均每人每年签到次数为10次，则这张表一年的数据量为 1亿条 每签到一次需要使用（8 + 8 + 1 + 1 + 3 +...</div></div></div></a><a class="pagination-related" href="/posts/redis/redis-feed-stream/" title="Feed流"><img class="cover" src="https://w.wallhaven.cc/full/5y/wallhaven-5yddx3.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-17</div><div class="info-item-2">Feed流</div></div><div class="info-2"><div class="info-item-1">Feed流是一种为用户持续提供内容的推送机制,本文详细介绍Feed流的两种实现模式：拉模式、推模式和推拉结合模式...</div></div></div></a><a class="pagination-related" href="/posts/redis/redis-message-queue/" title="Redis消息队列"><img class="cover" src="https://w.wallhaven.cc/full/3q/wallhaven-3qod59.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-11</div><div class="info-item-2">Redis消息队列</div></div><div class="info-2"><div class="info-item-1">Redis消息队列详解：介绍了Redis实现消息队列的三种方式 - List、PubSub和Stream。重点讲解了Stream的ACK确认机制、消费者组模式，以及如何通过Java代码实现通用的异步消息处理系统。Stream方式具备消息可回溯、多消费者支持、阻塞读取和消息确认等特性，是生产环境的推荐选择。  Redis消息队列什么是消息队列什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：  消息队列：存储和管理消息，也被称为消息代理（Message Broker） 生产者：发送消息到消息队列 消费者：从消息队列获取消息并处理消息  使用队列的好处在于解耦：以快递配送为例，快递员（生产者）将快递放入快递柜（消息队列），用户（消费者）随时从快递柜取货。这种异步处理方式避免了快递员等待用户在家的时间浪费。 在秒杀场景中：用户下单后，系统快速校验条件并将订单信息发送到消息队列，后台服务异步处理订单，既实现了系统解耦，又提升了响应速度。 Redis 作为消息队列的优势：虽然有 Kafka、RabbitMQ 等专业 MQ 中间件，但如果项目中已使用...</div></div></div></a><a class="pagination-related" href="/posts/redis/redis-set/" title="Redis的Set结构完整指南"><img class="cover" src="https://w.wallhaven.cc/full/9o/wallhaven-9o57ox.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-12</div><div class="info-item-2">Redis的Set结构完整指南</div></div><div class="info-2"><div class="info-item-1">Redis Set和ZSet数据结构的完整使用指南，包含基本操作、应用场景和实战代码。   Redis Set结构完整指南Set结构基本概念Set是Redis中的无序集合，具有以下特性：  唯一性：元素不重复s 无序性：元素没有固定顺序 快速查找：O(1)时间复杂度判断元素是否存在  数据结构123456Set 结构：key: &quot;user:tags&quot;├── &quot;java&quot;├── &quot;redis&quot; ├── &quot;spring&quot;└── &quot;mysql&quot;  基本操作Java代码示例1234567891011121314151617// 添加元素stringRedisTemplate.opsForSet().add(&quot;user:tags&quot;, &quot;java&quot;, &quot;redis&quot;, &quot;spring&quot;);// 判断元素是否存在Boolean exists =...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">JUC并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFJUC"><span class="toc-number">1.1.</span> <span class="toc-text">1. 什么是JUC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">2. 线程和进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">1）进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">2）线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E5%B9%B6%E5%8F%91"><span class="toc-number">1.2.3.</span> <span class="toc-text">3）并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E5%B9%B6%E8%A1%8C"><span class="toc-number">1.2.4.</span> <span class="toc-text">4）并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.5.</span> <span class="toc-text">5）线程的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%BC%89wait-sleep"><span class="toc-number">1.2.6.</span> <span class="toc-text">6）wait&#x2F;sleep</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Lock"><span class="toc-number">1.3.</span> <span class="toc-text">3.Lock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E4%BC%A0%E7%BB%9F%E7%9A%84-synchronized"><span class="toc-number">1.3.1.</span> <span class="toc-text">1）传统的 synchronized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89Lock"><span class="toc-number">1.3.2.</span> <span class="toc-text">2）Lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Synchronized-%E4%B8%8ELock-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. Synchronized 与Lock 的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.4.</span> <span class="toc-text">4. 生产者和消费者的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89Synchronzied-%E7%89%88%E6%9C%AC"><span class="toc-number">1.4.1.</span> <span class="toc-text">1）Synchronzied 版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98%EF%BC%88%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92%EF%BC%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">2）存在问题（虚假唤醒）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89Lock%E7%89%88"><span class="toc-number">1.4.3.</span> <span class="toc-text">3）Lock版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89Condition%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.4.4.</span> <span class="toc-text">4）Condition的优势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8%E9%94%81%E7%8E%B0%E8%B1%A1"><span class="toc-number">1.5.</span> <span class="toc-text">5. 8锁现象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">1.5.1.</span> <span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%9B%86%E5%90%88%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="toc-number">1.6.</span> <span class="toc-text">6. 集合不安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89List-%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="toc-number">1.6.1.</span> <span class="toc-text">1）List 不安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89set-%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="toc-number">1.6.2.</span> <span class="toc-text">2）set 不安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89Map%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="toc-number">1.6.3.</span> <span class="toc-text">3）Map不安全</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Callable"><span class="toc-number">1.7.</span> <span class="toc-text">7. Callable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%B8%B8%E7%94%A8%E7%9A%84%E8%BE%85%E5%8A%A9%E7%B1%BB"><span class="toc-number">1.8.</span> <span class="toc-text">8. 常用的辅助类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89CountDownLatch"><span class="toc-number">1.8.1.</span> <span class="toc-text">1）CountDownLatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89CyclickBarrier"><span class="toc-number">1.8.2.</span> <span class="toc-text">2）CyclickBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89Semaphore"><span class="toc-number">1.8.3.</span> <span class="toc-text">3）Semaphore</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">1.9.</span> <span class="toc-text">9. 读写锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">1.10.</span> <span class="toc-text">10. 阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89BlockQueue%E6%A6%82%E8%BF%B0"><span class="toc-number">1.10.1.</span> <span class="toc-text">1）BlockQueue概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayBlockingQueue"><span class="toc-number">1.10.2.</span> <span class="toc-text">ArrayBlockingQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97SynchronousQueue"><span class="toc-number">1.10.3.</span> <span class="toc-text">2）同步队列SynchronousQueue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.11.</span> <span class="toc-text">11. 线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9A"><span class="toc-number">1.11.1.</span> <span class="toc-text">1）线程池的好处：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9A%E4%B8%89%E5%A4%A7%E6%96%B9%E6%B3%95"><span class="toc-number">1.11.2.</span> <span class="toc-text">2）线程池：三大方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E4%B8%83%E5%A4%A7%E5%8F%82%E6%95%B0"><span class="toc-number">1.11.3.</span> <span class="toc-text">3）七大参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">1.11.4.</span> <span class="toc-text">4）拒绝策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.11.5.</span> <span class="toc-text">5）如何设置线程池的大小</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%9B%9B%E5%A4%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.12.</span> <span class="toc-text">12. 四大函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89Function-%E5%87%BD%E6%95%B0%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.12.1.</span> <span class="toc-text">1）Function 函数型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89Predicate-%E6%96%AD%E5%AE%9A%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.12.2.</span> <span class="toc-text">2）Predicate 断定型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89Suppier-%E4%BE%9B%E7%BB%99%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.12.3.</span> <span class="toc-text">3）Suppier 供给型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89Consummer-%E6%B6%88%E8%B4%B9%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.12.4.</span> <span class="toc-text">4）Consummer 消费型接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-Stream-%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97"><span class="toc-number">1.13.</span> <span class="toc-text">13. Stream 流式计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-ForkJoin"><span class="toc-number">1.14.</span> <span class="toc-text">14. ForkJoin</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89ForkJoin-%E7%89%B9%E7%82%B9%EF%BC%9A-%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96%EF%BC%81"><span class="toc-number">1.14.1.</span> <span class="toc-text">1）ForkJoin 特点： 工作窃取！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8ForkJoin"><span class="toc-number">1.14.2.</span> <span class="toc-text">2）如何使用ForkJoin?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%9B%9E%E8%B0%83%EF%BC%9A%E4%BB%8E%E7%90%86%E5%BF%B5%E5%88%B0-CompletableFuture-%E5%AE%9E%E6%88%98"><span class="toc-number">1.15.</span> <span class="toc-text">异步编程与回调：从理念到 CompletableFuture 实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E7%90%86%E5%BF%B5%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E6%AD%A5%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%EF%BC%9F"><span class="toc-number">1.15.1.</span> <span class="toc-text">1. 核心理念：什么是异步？什么是回调？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83-Callback-%EF%BC%9F"><span class="toc-number">1.15.1.1.</span> <span class="toc-text">什么是回调 (Callback)？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E6%AD%A5-Asynchronous-%EF%BC%9F"><span class="toc-number">1.15.1.2.</span> <span class="toc-text">什么是异步 (Asynchronous)？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-CompletableFuture-%E5%85%A5%E9%97%A8%EF%BC%9A%E5%88%9B%E5%BB%BA%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.15.2.</span> <span class="toc-text">2. CompletableFuture 入门：创建异步任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%EF%BC%9Aget-%E6%98%AF%E9%98%BB%E5%A1%9E%E7%9A%84%EF%BC%81"><span class="toc-number">1.15.2.1.</span> <span class="toc-text">重要：get() 是阻塞的！</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B%EF%BC%9A%E6%9E%84%E5%BB%BA%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">1.15.3.</span> <span class="toc-text">3. 核心能力：构建异步回调流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">1.15.3.1.</span> <span class="toc-text">示例：一个完整的异步处理流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B8%B8%E7%94%A8-API-%E5%B0%8F%E7%BB%93%E4%B8%8E%E5%AF%B9%E6%AF%94"><span class="toc-number">1.15.4.</span> <span class="toc-text">4. 常用 API 小结与对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#get-vs-join-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.15.4.1.</span> <span class="toc-text">get() vs join() 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BB%84%E5%90%88%E5%A4%9A%E4%B8%AA%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.15.5.</span> <span class="toc-text">5. 组合多个异步任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6-JDK-9"><span class="toc-number">1.15.6.</span> <span class="toc-text">6. 超时控制 (JDK 9+)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E5%AF%B9%E6%AF%94%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.15.7.</span> <span class="toc-text">异步回调对比同步任务的优势</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BC%A0%E7%BB%9F%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%EF%BC%9A%E8%A2%AB%E5%8A%A8%E7%9A%84%E2%80%9C%E9%98%BB%E5%A1%9E%E2%80%9D"><span class="toc-number">1.15.7.1.</span> <span class="toc-text">1. 传统同步模式：被动的“阻塞”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%B8%BB%E5%8A%A8%E7%9A%84%E2%80%9C%E7%AD%89%E5%BE%85%E2%80%9D%E6%88%96%E2%80%9C%E7%BB%A7%E7%BB%AD%E5%B7%A5%E4%BD%9C%E2%80%9D"><span class="toc-number">1.15.7.2.</span> <span class="toc-text">2. 异步回调模式：主动的“等待”或“继续工作”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93%EF%BC%9A%E4%BB%A5-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%BA%E4%BE%8B"><span class="toc-number">1.15.7.3.</span> <span class="toc-text">关键区别总结：以 Web 服务器为例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">1.15.8.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-JMM"><span class="toc-number">1.16.</span> <span class="toc-text">16. JMM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%AF%B9Volatile-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.16.1.</span> <span class="toc-text">1）对Volatile 的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AFJMM%EF%BC%9F"><span class="toc-number">1.16.2.</span> <span class="toc-text">2）什么是JMM？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-volatile"><span class="toc-number">1.17.</span> <span class="toc-text">17. volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">1.17.1.</span> <span class="toc-text">1）保证可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">1.17.2.</span> <span class="toc-text">2）不保证原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92"><span class="toc-number">1.17.3.</span> <span class="toc-text">3）禁止指令重排</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E6%AC%A1%E5%AF%B9%E8%AF%9D%E6%80%BB%E7%BB%93"><span class="toc-number">1.17.3.1.</span> <span class="toc-text">本次对话总结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%97%AE%E9%A2%98%E6%A0%B9%E6%BA%90%EF%BC%9A%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92-Instruction-Reordering"><span class="toc-number">1.17.3.1.1.</span> <span class="toc-text">1. 问题根源：指令重排 (Instruction Reordering)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-volatile-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.17.3.1.2.</span> <span class="toc-text">2. volatile 的解决方案</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C-Memory-Barrier"><span class="toc-number">1.17.3.1.3.</span> <span class="toc-text">3. 核心机制：内存屏障 (Memory Barrier)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%85%B3%E9%94%AE%E7%82%B9%E6%BE%84%E6%B8%85-%E9%92%88%E5%AF%B9-x-a-%E5%92%8C-y-b-%E7%9A%84%E6%8F%90%E9%97%AE"><span class="toc-number">1.17.3.1.4.</span> <span class="toc-text">4. 关键点澄清 (针对 x&#x3D;a 和 y&#x3D;b 的提问)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E6%80%BB%E7%BB%93"><span class="toc-number">1.17.4.</span> <span class="toc-text">4）总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E7%8E%A9%E8%BD%AC%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.18.</span> <span class="toc-text">18. 玩转单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.18.1.</span> <span class="toc-text">什么是单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">1.18.2.</span> <span class="toc-text">单例模式的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.18.3.</span> <span class="toc-text">如何实现单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-number">1.18.4.</span> <span class="toc-text">1）饿汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89DCL%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-number">1.18.5.</span> <span class="toc-text">2）DCL懒汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.18.6.</span> <span class="toc-text">3）静态内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.18.7.</span> <span class="toc-text">4）枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.18.7.1.</span> <span class="toc-text">枚举类单例模式实用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%EF%BC%9A%E5%85%A8%E5%B1%80%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">1.18.7.2.</span> <span class="toc-text">场景：全局异步任务处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8D%95%E4%BE%8B%E7%9A%84%E4%BC%AA%E4%BB%A3%E7%A0%81"><span class="toc-number">1.18.7.2.1.</span> <span class="toc-text">1. 线程池单例的伪代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9C%A8%E5%BA%94%E7%94%A8%E4%B8%8D%E5%90%8C%E6%A8%A1%E5%9D%97%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%AF%A5%E5%8D%95%E4%BE%8B%E7%9A%84%E4%BC%AA%E4%BB%A3%E7%A0%81"><span class="toc-number">1.18.7.2.2.</span> <span class="toc-text">2. 在应用不同模块中使用该单例的伪代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%B8%BB%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E4%BC%AA%E4%BB%A3%E7%A0%81"><span class="toc-number">1.18.7.2.3.</span> <span class="toc-text">3. 主程序流程伪代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">1.18.7.2.4.</span> <span class="toc-text">伪代码核心思想</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.18.7.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CAS"><span class="toc-number">1.19.</span> <span class="toc-text">19. 深入理解CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E4%BB%80%E4%B9%88%E6%98%AFCAS%EF%BC%9F"><span class="toc-number">1.19.1.</span> <span class="toc-text">1）什么是CAS？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E6%80%BB%E7%BB%93"><span class="toc-number">1.19.2.</span> <span class="toc-text">2）总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8"><span class="toc-number">1.20.</span> <span class="toc-text">20. 原子引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%90%84%E7%A7%8D%E9%94%81%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.21.</span> <span class="toc-text">21. 各种锁的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">1.21.1.</span> <span class="toc-text">1）公平锁，非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-%E9%80%92%E5%BD%92%E9%94%81"><span class="toc-number">1.21.2.</span> <span class="toc-text">2）可重入锁(递归锁)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">1.21.3.</span> <span class="toc-text">3）自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E6%AD%BB%E9%94%81"><span class="toc-number">1.21.4.</span> <span class="toc-text">4）死锁</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(https://w.wallhaven.cc/full/je/wallhaven-je8q9w.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Cx</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script></div></body></html>